# 1161. Maximum Level Sum of a Binary Tree

В данной задаче можно использовать горизонтальный обход дерева.

То есть сначала один уровень, потом второй уровень будем обходить и так далее

```python
class Solution:
    def max_level_sum(self, root: 'TreeNode') -> int:
        # Инициализируем максимум
        m = root.val
        # Так же инициализируем результат
        result = 1
        # И какой сейчас уровень
        level = 0
        # Элементы текущего уровня
        items = [root]
        # Итерируемся до тех пор, 
        # пока у нас есть элементы
        while items:
            # Увеличиваем уровень
            level += 1
            # Находим сумму уровня
            sum_ = sum(i.val for i in items)
            # Если сумма больше, максимума обновляем
            # максимум и результат
            if sum_ > m:
                m = sum_
                result = level
            # Находим все элементы следующего уровня
            new_items = []

            for node in items:
                if node.left is not None:
                    new_items.append(node.left)
                if node.right is not None:
                    new_items.append(node.right)
            # Обновляем элементы текущего уровня
            items = new_items
        # Возвращаем результат
        return result
```

А теперь можно оченить сложность алгоритма

Мы проходим каждый элемент в дерева и тратим на него константное время, поэтому сложность по времени будет O(N).

Так же количество элементов в items зависит от количества элементов в дерева, поэтому сложность по памяти так же будет O(N).

В данной задаче можно использовать вместо массива `collections.deque` и складывать туда не элементы, а элементы и их уровни.

Тогда мы будем в среднем тратить меньше памяти, но верхняя оценка от этого не изменится.