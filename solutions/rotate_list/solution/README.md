# Rotate List Solution

## Описание:

Начнем с одного свойства, которое нам поможет после. Если связанный список повернуть на кол-во элементов в нем, то мы получим изначальный связанный список.

```
1 -> 2 -> 3
k = 3

3 -> 1 -> 2
2 -> 3 -> 1
1 -> 2 -> 3
```
Так будет всегда и с любый связанным списком. Запомним этот момент.

Теперь необходимо научиться двигать связанный список, так ? Нет конечно. Нам не надо двигать никакой список, надо просто замкнуть связанный список с хвоста на голову и найти новую голову. в этом месте образуется разрыв.


```
k = 3

head
  |
  V
  1 -> 2 -> 3 -> 4 -> 5
```

Замыкаем список на себя

```
head
  |
  V
  1 -> 2 -> 3 -> 4 -> 5
  ^                   |
  |                   V
   <-------------------
```
Те теперь последняя нода ссылается на первую.

Теперь надо подумать где это кольцо разрезать ? Давайте рассуждать:
- если k = 1, то мы забираем 1 ноду с конца, Если 2, то 2. Значит нам надо отсчитать от конца k нод и совершить разрыв. Это и будет ответ


```
          head
            |
            V
  1 -> 2    3 -> 4 -> 5
  ^                   |
  |                   V
   <-------------------

# развернем

3 -> 4 -> 5 -> 1 -> 2
```

Подобный поиск ноды мы уже разбирали в задаче [Swapping Nodes in a Linked List Problem](../../swapping_nodes_in_a_linked_list/solution/README.md).
