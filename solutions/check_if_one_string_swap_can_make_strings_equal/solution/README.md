# Check if One String Swap Can Make Strings Equal

Для решения задачи необходимо пройтись параллельно по обоим строкам и сравнивать буквы.

Если это первое несовпадение, то сохранить обе буквы, если не первое, то сравнить с первым, если оно противоположно первому, значит можно обменять местами буквы и подстроки до этого момента будут совпадать.

Если больше несовпадений нет, то вернуть True.

```python
class Solution:
    def are_almost_equal(self, s1: str, s2: str) -> bool:
        # Сначала проверяем длину, так как если длина не совпадает, то смысла проверять нет
        if len(s1) != len(s2):
            return False
        
        # Это разные элементы
        diff_letters = None
        # Это переменная говорящая, были ли уже несовпадения
        has_diff = False
        
        # Проходимся параллельно по буквам обеих строк
        for i1, i2 in zip(s1, s2):
            # Если совпадают, идём дальше
            if i1 == i2:
                continue
                
            # Если уже были несовпадения, то возвращаем False
            if has_diff:
                return False
        
            if diff_letters is None:
                # Если это первое несовпадение, просто сохраняем буквы
                diff_letters = (i1, i2)
            # Если несовпадение противоположно первому, 
            # значит можно обменять местами буквы и подстроки до этого момента будут совпадать
            elif diff_letters == (i2, i1):
                # Говорим, что несовпадений нет
                diff_letters = None
                # Говорим что уже обменяли пару букв
                has_diff = True
            else:
                # Иначе возвращаем False
                return False
            
        # Если смена букв не окончена
        # То возвращаем False
        return diff_letters is None
```

Как мы можем видеть - мы проходимся по обеим строкам и не используем дополнительную память.

То есть по времени - O(N)

По памяти - O(1)