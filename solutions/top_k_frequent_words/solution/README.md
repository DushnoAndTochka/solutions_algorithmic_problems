# TopKFrequentWords Solution

## Описание
Для решения задачи, нам надо понять какие слова встречаются чаще остальных. Если бы это было все, то задача свелась бы к примитиву. Мы могли бы посчитать сколько раз встречается каждое слово и отсортироваться в порядке убывания.

Приблизительно так бы выглядел код:
```python
from collections import Counter

def top_k_frequent(self, words: list[str], k: int) -> list[str]:
    return Counter(words).most_common(k)
```

> most_common - Метод класса Counter. Возвращает указанное кол-во самых популярных объектов

<details>
  <summary>Ну или если подрасписать без сахара и оптимизаций.</summary>

```python
def top_k_frequent(self, words: list[str], k: int) -> list[str]:
    word_counter = dict()

    for word in words:
        if word in word_counter:
            word_counter[word] += 1
        else:
            word_counter[word] = 1
    
    return sorted(word_counter.values(), reverse=True)[:k]
```
> Тут откровенно много что можно улучшить. Но данный код скорее для понимания.

</details>
<br>
Решение в одну строчку, красота ? А как же, только вот оно нам не подойдет. Данное решение не учитывает тот факт, что нам надо и слова дофильтровать, в том случае если их кол-во одинаково.

Что делать ? Давайте вспомним, что питон умеет фильтровать "пары"(`tuple`). Как он это делает ? Сначала берет первый элемент в "паре" и сравнивает так же с первым, если они равны, то дофильтровывает по второму. Очень похоже на то, что нам как раз и надо.

```python
from collections import Counter

def top_k_frequent(self, words: list[str], k: int) -> list[str]:
    word_counter = Counter(words).most_common(k)
    return sorted(word_counter, key=lambda w: (-word_counter[w], w))[:k]
```
<details>
  <summary>Ну или если подрасписать без сахара.</summary>

```python
def top_k_frequent(self, words: list[str], k: int) -> list[str]:
    word_counter = dict()

    for word in words:
        if word in word_counter:
            word_counter[word] -= 1
        else:
            word_counter[word] = -1
    
    return return sorted(word_counter, key=lambda w: (word_counter[w], w))[:k]
```
Так как мы сразу вычитаем повторения, то отрицательный знак нам тут не нужен.

</details>
<br>
Давайте поймем что тут вообще происходит. С счетчиком мы в целом уже думаю познакомились и расписывать нет смысла. НО вот что за странная сортировка ???

Классическая сортировка, отсортирует от меньшего к большему. Нам такое не подойдет. Значит можно использовать `reverse=True` ? Нет. Ведь у слов ровно обратная история. Буква `a < b`, значит при `reverse` сортировки, слова будут идти не в алфавитном, а в обратно порядке. Те нам надо отсортировать слова в одном направлении(от меньшего к большему), а числа наоборот(от большего к меньшему). Что бы не городить огороды, можно домножить все числа на `-1`, тогда их поведение поменятся и станет однородным с алфавитом. `-6 < -1` логично ? А `a < b`, значит мы теперь можем просто отсортировать наши пары от меньшего к большему и получим "правильную" сортировку сразу по двум полям. 