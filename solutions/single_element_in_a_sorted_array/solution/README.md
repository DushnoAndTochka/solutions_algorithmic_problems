# Single Element in a Sorted Array Solution

## Описание

Для начала мы можем заметить что массив отсортирован. Каждый его элемент встречается четное кол-во раз, а какой-то один нечетное и его надо как раз найти.

### Решение в лоб:

Ну первая мысль. Давайте пойдем по массиву и будем считать сколько раз встретили элемент. Если встретили новый элемент, то смотрим сколько раз мы встретили предыдущий.

Код будет каким-то таким

```python
class Solution:
    def singleNonDuplicate(self, nums: List[int]) -> int:
        cur = nums[0]
        counter = 0

        for num in nums:
            if num == cur:
                counter += 1
            else:
                if counter % 2 != 0:
                    return cur
                cur = num
                counter = 1
        return cur
```

Тут даже комментировать нечего. Считаем, нашли новое, проверяем.

### Решение через XOR:

> XOR — это логический оператор, работающий с битами. Давайте обозначим его ^. Если два получаемых им на входе бита одинаковы, то результат будет равен 0, в противном случае 1.
> Статейка показалась не плохой https://habr.com/ru/companies/vdsina/articles/538298/

В чем смысл в двух словах.

Если через `XOR` мы сложим два одинаковых числа, то получим ноль, А если два разных, то получим их сумму... Все наши числа упорядочены, хотя для нас это не имеет никакого значения, каждое число будет убиваться об копию и только одно число, которое не имеет копии останется в живых =) 

```python
class Solution:
    def single_non_duplicate(self, nums: list[int]) -> int:
        result = 0

        for i in nums:
            result ^= i

        return result
```

Вот и все решение данной задачи. Мы просто просуммируем с помощью XOR все числа и получим ответ. 

### Решение через бинарный поиск:

>Один из подписчиков канала заметил, что есть более оптимальное решение. Более того, сама задача требует решения за O(log(n))... Значит решения выше не совсем актуальны для данной задачи, так как они линейны.
>
> Отдельное спасибо Сергею Гриценко! Он подсветил данный промах

Так в чем же идея ? По условию задачи нам гарантируется, что каждое число имеет пару, кроме одного. Более того, каждое число встречается не больше двух раз. То есть не может быть две пары одного и того же числа. И вот это очень важно! Именно это я упустил при прочтении.

Мы имеем некое множество чисел:

```
nums = [1, 1, 2, 2, 3, 3, 4, 5, 5]
```

Так как все числа имеют пару и только одно не имеет, значит кол-во символов у нас гарантированно нечетное. Запомним это

Теперь давайте выставим указатели. Что мы ищем ? Мы ищем такое число, которое по соседству не имеет своей пары.

Заранее мы проверяем, что на концах нет ответа. Это необходимо для того, что бы не выйти за границы массива, ведь мы смотрим соседей справа и слева. Значит левый и правый указатели не могут стоять на концах.

```
    lp       mp       rp
    |        |        |
    V        V        V
[1, 1, 2, 2, 3, 3, 4, 5, 5]
```

Теперь мы проверяем, что указатель находится на числе, которое имеет по соседству пару. Иначе это и есть ответ.

Теперь главная хитрость. В нашем случае `3` имеет пару. Так куда же двигать указатель ???
На самом деле все просто. Тут работает вопрос четности и не четности. Все числа идут по парно, значит первое число в паре, всегда находится на четном индексе, но это происходит до тех пор, пока мы не встретим нечетное.

Не понятно ??

```
    lp       mp       rp
    |        |        |
    V        V        V
[1, 1, 2, 2, 3, 3, 4, 5, 5]
       ^     ^        ^
       |     |        |
      чет   чет     не чет
       2     4        7 
```

Значит мы смотрим на четность. Если четность не нарушена, то одинокое число еще не было встречено и оно находится правее! иначе мы его уже где то встретили и необходимо двигаться левее.


```
             lp mp    rp
             |  |     |
             V  V     V
[1, 1, 2, 2, 3, 3, 4, 5, 5]
```

```
                lp mp rp
                |  |  |
                V  V  V
[1, 1, 2, 2, 3, 3, 4, 5, 5]

result = 4
```


```python
class Solution:
    def singleNonDuplicate(self, nums: List[int]) -> int:
        n = len(nums)
        # проверяем границы
        if n == 1 or nums[0] != nums[1]:
            return nums[0]
        if nums[-2] != nums[-1]:
            return nums[-1]

        # левый и правый встают на 2 и
        # предпоследний элементы
        lp = 1
        rp = n - 2

        while lp <= rp:
            # ищем середину
            mp = (lp + rp) // 2

            # Если слева и справа находится отличное число,
            # то мы нашли ответ
            if nums[mp] != nums[mp - 1] and nums[mp] != nums[mp + 1]:
                return nums[mp]

            # если mp на нечетном инжекс и число слева
            # равно числу на mp,
            # то принцип четности не нарушен
            # если mp на четном, то смотрим правее.
            # если четность не нарушена, то одинокое
            # число правее
            if (
                mp % 2 == 1
                and nums[mp] == nums[mp - 1]
                or mp % 2 == 0
                and nums[mp] == nums[mp + 1]
            ):
                lp = mp + 1
            else:
                # иначе принцип нарушен и
                # одинокое число межд lp и mp
                rp = mp - 1
```