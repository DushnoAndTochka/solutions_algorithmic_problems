# Single Element in a Sorted Array Solution

## Описание

Для начала мы можем заметить что массив отсортирован. Каждый его элемент встречается четное кол-во раз, а какой-то один нечетное и его надо как раз найти.

Ну первая мысль. Давайте пойдем по массиву и будем считать сколько раз встретили элемент. Если встретили новый элемент, то смотрим сколько раз мы встретили предыдущий.

Код будет каким-то таким

```python
class Solution:
    def singleNonDuplicate(self, nums: List[int]) -> int:
        cur = nums[0]
        counter = 0

        for num in nums:
            if num == cur:
                counter += 1
            else:
                if counter % 2 != 0:
                    return cur
                cur = num
                counter = 1
        return cur
```

Тут даже комментировать нечего. Считаем, нашли новое, проверяем.

НО зачем мы вообще это все будем делать ? Зачем нам вообще информация о том, что он сортирован ? Это ж просто бесмысленно, если ты знаешь про `XOR`...

> XOR — это логический оператор, работающий с битами. Давайте обозначим его ^. Если два получаемых им на входе бита одинаковы, то результат будет равен 0, в противном случае 1.
> Статейка показалась не плохой https://habr.com/ru/companies/vdsina/articles/538298/

В чем смысл в двух словах.

Если через `XOR` мы сложим два одинаковых числа, то получим ноль, А если два разных, то получим их сумму... Все наши числа упорядочены, хотя для нас это не имеет никакого значения, каждое число будет убиваться об копию и только одно число, которое не имеет копии останется в живых =) 

```python
class Solution:
    def single_non_duplicate(self, nums: list[int]) -> int:
        result = 0

        for i in nums:
            result ^= i

        return result
```

Вот и все решение данной задачи. Мы просто просуммируем с помощью XOR все числа и получим ответ. 