# Pascal's Triangle Solution

## Решение в лоб:
Давайте начнем с простого решения, которое вытекает из самой задачи. Мы Зная предыдущую строку, мы можем на ходу вычислять число как сумму предыдущего индекса и текущего в предыдущей строке. Кроме крайних чисел(они единички).

### Как это выглядит ?

```python
class Solution:
    def generate(self, num_rows: int) -> list[list[int]]:
        result = []

        if num_rows == 0:
            return result

        # сразу добавляем вершину, так как в цикле не
        # хочется держать лишние if.
        result.append([1])

        for n in range(1, num_rows):
            # создаем новую строку
            row = [1]

            for m in range(1, n):
                # заполняем через вычисление из предыдущей строки
                row.append(
                    result[-1][m] + result[-1][m - 1]
                    )
            # закрывающая единица
            row.append(1)
            # добавляем в резалт
            result.append(row)

        return result
```

Это решение уже будет работать всегда правильно. Смущает то, что нам постоянно приходится лезть в предыдущую строку. Не сказать что это дорогая операция, но все же она смущает.

## Решение через теорию "Треугольника Паскаля".

Что бы решение было более оптимальным, стоит познакомиться с теорией по треугольнику Паскаля. Мне понравилась [статейка на Википедиа](https://ru.wikipedia.org/wiki/Треугольник_Паскаля). Там очень много полезного и есть разные формулы, но они достаточно сложные для расчетов. Где то присутствуют факториалы, что сильно усложняет расчеты. НО из всех формул можно вывести формулу, которая позволит расчитывать любое число в трегольнике Паскаля, если знать три основных числа:
- Номер строки(индексация с нуля)
- Индекс числа в строке(индексация с нуля)
- Предыдущее число.

Так уж выходит, что мы всегда знаем первое число и остальные данные. Значит мы легко можем вычислять строки. 

Формула, которую я для себя вывел, выглядит так:

```python
(prev_val * (row_number - current_val_index + 1)) // current_val_index
```

Для оптимизации можно испольховать симметрию и не высчитывать вторую половину треугольника, но это я оставлю вам.

### Как это выглядит ?

```python
class Solution:
    def generate(self, num_rows: int) -> list[list[int]]:
        result = []

        for n in range(num_rows):
            row = [1]
            result.append(row)

            for m in range(1, n + 1):
                row.append(row[-1] * (n - m + 1) // m)

        return result
```
