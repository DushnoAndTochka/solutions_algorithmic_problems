# Number of Provinces

Данную задачу можно решить несколькими способами, но я тут разберу только один.

## Решение с структурой данных DisjointSet

> Данная структура данных хорошо описана в <a href="https://stepik.org/lesson/41236/step/1?unit=19820"> бесплатном курсе на Stepic</a>.
> Всем рекомендую посмотреть подробное описание на курсе самой структуры и почему она работает за почти константное время (каждая операция на реальных значениях работает за константу).

Начнем с самой структуры DisjointSet.


```python

class DisjointSet:
    
    def __init__(self, n: int):
        ...
    
    def find(self, i: int) -> int:
        ...
    
    def union(self, i: int, j: int) -> None:
        ...
```

DisjointSet - системы непересекающихся множеств. 

То есть у нас есть структура, которую можно инициализировать количеством элементов.  

После этого можно найти идентификатор элемента - то есть идентификатор непересекающегося множества.

Можно объеденить два непересекающихся множества используя метод union.

После объединения элементов, метод find будет возвращать для них одинаковые значения.


То есть в нашем примере:

```python
matrix = [
    [1, 1, 0],
    [1, 1, 0],
    [0, 0, 1]
]
```

Для того что бы получить результат, нужно инициализиловать DisjointSet с аргументом 3.
```python
s = DisjointSet(3)
```

И после этого выполнить объединение 0 и 1
```python
s.union(0, 1)
```

И после найти идентификаторы для каждого элемента и вернуть количество уникальных идентификаторов.

Вот всё решение

```python
class Solution:
    def find_circle_num(self, is_connected: list[list[int]]) -> int:
        n = len(is_connected)
        # Инициализируем DisjointSet
        s = DisjointSet(n)
        
        # Проходимся по всем элементам, 
        # которые выше диагонали матрици, 
        # так как матрица симметрична
        # и проходиться по всем элементам смысла нет
        for i in range(n):
            # Здесь range(i + 1, n) так как хотим пройтись только по элементам, 
            # которые выше главной диагонали
            for j in range(i + 1, n):
                # Если города соединены, то выполняем union для этих элементов
                if is_connected[i][j] == 1:
                    s.union(i, j)
        
        # Находим уникальный идентификаторы 
        ids = set()
        for i in range(n):
            ids.add(s.find(i))
            
        # Возвращаем количество уникальных идентификаторов
        return len(ids)
```

А теперь разберем сложность алгоритма.

Мы проходимся по всем элементам, которые выше главной диагонали - а это равно (N^2)/2.

То есть временная сложность равно O(N^2).

Напоминаю, что union - работает в среднем за константное время.

Так же мы проходимся по элементам и собираем ids - это работает за линию и никак не влияет на временную сложность.

Опять напоминаю, что find так же работает в среднем за линию.

Сложность по памяти - мы используем ids - который может использовать линейную память и сам DisjointSet так же использует линейную сложность, поэтому по памяти у нас линия.
