# Triangle Solution

## Описание

Для начала, как и всегда, стоит понять что же от нас на самом деле требуется. По условию задачи необходимо найти самый "дешевый" спуск от вершины к основанию треугольника. Может показаться, что мы можем сделать это с ходу, просто выбирая самые маленькие числа, которые нам встречаются. Это решение окажется не верным, так как может оказаться, что на одном из шагов будут супер большие числа, которые поломают все, а рядом будет путь, который до этого казался не выгодным, но на этом шаге стал сильно дешевле. От сюда появляется вывод, что нам надо найти все "минимальные" пути ко всем точкам в основании. После выбрать самое "дешевое" и это будет ответом. 

Думаю многие проходили лабиринты на листочках или чем-то подобном. Так вот порой их удобней решать не от начала, а от конца. Первая мысль которая приходит тут именно такая. Почему бы не попытаться подняться от каждой точки основания ? Все еще сложно, потому что путей слишком много. Для упрощения решения необходимо заметить следующее.

- У любого треугольника, левая точка основания имеет только лишь один путь.(тоже самое и с крайней правой точкой)

### Решение по левой грани:

```

   / 1
  / 1 2
 / 1 2 3
/ 1 2 3 4
  ^
  |
крайняя
левая точка
```

Поднимаясь от этой точки у нас просто нет выбора. 

Что нам это дает ? Предположим что мы знаем, сколько стоит подъем у этой цепочки на каждом уровне. Перепишем треугольник так, что бы в каждой точке по краю, все было посчитано.


```

   / 1                    1
  / 1 2                  2
 / 1 2 3                3
/ 1 2 3 4              4
  ^                    ^
  |                    |
крайняя           посчитанный путь
левая точка       для левой точки
```

Те теперь мы знаем сколько стоит путь в любом месте этого куска подъема. Что дальше ? Дальше мы можем заметить, что если мы "отделим" левую грань от всего треугольника, то история получится та же самая

```

    1 /
   2 / 2
  3 / 2 3
 4 / 2 3 4
     ^
     |
  крайняя
  левая точка
```

Мы получаем треугольник поменьше, и так же можем обсчитать новую грань. Есть одно НО. Теперь мы можем выбирать что выгодней, свернуть на путь который был пройден или остаться на новой прямой.


```

   1 /                    1 /
  1 / 2                  2 / 3
 1 / 2 3                3 / 4
1 / 2 3 4              4 / 5
    ^                      ^
    |                      |
  крайняя              посчитанный путь
левая точка            для левой точки
```

Как видно, для каждого из уровня было выгодно сложение с числом, которое выше и левее. Теперь мы имеем уже два ряда, которые просчитаны. Дальше логика в целом ничем не отличается. Мы можем легко посчитать все остальное и получить вот такой треугольник

```

   1                    1
  1 2                  2 3
 1 2 3                3 4 6
1 2 3 4              4 5 7 10
```

Выбираем самое малое число в основнии. Это и будет сумма для самого "дешевого" спуска.

### Решение через спуск вниз:

Алгоритм рабочий, но не самый приятный в реализации. Можем ли мы его упростить так, что бы и логика сохранилась и написать было гораздо легче ?
Ответ ДА. В этом случае мы решали по левой грани. Надо было слишком много изощраться. Теперь надо заметить еще одну особенность. Помним что левая и правая грань имеет единственную сумму спуска, а любая другая зависит именно от родительской суммы. В таком случае мы можем спускаться построчно и считать оптимальную сумму для каждой точки в треугольнике. Выглядит это приблизительно так

```
Исходный треугольник:

        1
       1 2
      1 2 3
     1 2 3 4
```

Шан 1:

Начинаем собирать итоговый. Так как верхушка статична, то ее сразу оставляем в покое и начинаем с второго уровня

```
         1
      1+1 2+1
```
Тут без альтернативы. Оба числа являются "крайними", поэтому выбирать не из чего.

Шаг 2:
Считаем следующий уровень

```
         1
      2     3
    1+2 2+2 3+3
        2+3
```

Крайние числа опять обсчитываются без альтернативно, у них только один родитель, Число по середине имеет два варианта подъема, поэтому выбираем самый "дешевый" `2+2`

Шаг 3:

```
         1
      2     3
    3    4    6
  1+3 2+4 3+4 4+6
      2+3 3+6  
```

Все тоже самое что и в предыдущем.

Итогом получаем

```
   1
  2 3
 3 4 6
4 5 7 10
```

Ответ тот же, что и в предыдущем варианте решения, только алгоритм куда проще по восприятию.
Осталось реализовать данный алгоритм.

```python
class Solution:
    def minimum_total(self, triangle: list[list[int]]) -> int:
        # Идем по строчно. 
        # Первую строку пропускаем(см. выше объяснение)
        for row_num in range(1, len(triangle)):
            # Работаем с каждым элементом текущей строки
            for element_index in range(len(triangle[row_num])):
                if element_index == 0:
                    # Если это первый элемент, то нет альтернативы,
                    # мы просто складываем его с первым элементом 
                    # предыдущей строки
                    left_prev_elem = triangle[row_num - 1][0]
                    triangle[row_num][element_index] += left_prev_elem
                elif element_index == len(triangle[row_num]) - 1:
                    # Если это последний элемент, то нет альтернативы,
                    # мы просто складываем его с последним элементом 
                    # предыдущей строки
                    right_prev_elem = triangle[row_num - 1][-1]
                    triangle[row_num][element_index] += right_prev_elem
                else:
                    # Если люой другой элемент, то мы смотрим
                    # на самомого "дешевого" родителя
                    # и берем именно его
                    triangle[row_num][element_index] += min(
                        triangle[row_num - 1][element_index - 1],
                        triangle[row_num - 1][element_index],
                    )

        # Это легко оптимизируется, но не увидел большого смысла.
        # Можно искать сразу в цикле выше, но так код выглядит почище.
        return min(triangle[-1])
```

В данном решении я схитрил и не стал создавать новый трегольник, что бы не жрать память. Таким образом по памяти у нас константа. Сложность алгоритма составляет `О(n)`.

### Решение через подъем:

Есть ли еще более простое решение ? На самом деле есть. Оно ровно противоположно предыдущему.(Спасибо подписчице Юле, что подсказала)

Что если полдниматься с предпоследней строке и смотреть куда можно шагнуть вниз. То есть находясь в точке какой либо строки, мы смотрим куда из нее дешевле всего шагнуть и, так же как и в предыдущем решении, накапливаем сумму. Итогом мы получаем сразу ответ и нам нет нужды дофильтровываться. Как это выглядит ?

```
Исходный треугольник:

        1
       1 2
      1 2 3
     1 2 3 4
```

Итерироваться начинаем с предпоследней строки.

```
      1+2 2+3 3+4
      1+1 2+2 3+3
     1   2   3   4
```

То есть мы стоя на предпоследней строке, смотрим какой из потомкв дешевле и начинаем накапливать сумму. Следом поднимаемся на строку выше

```
        1+4 2+4
        1+2 2+6
       2   4   6
     1   2   3   4
```

Ничего нового. Выбираем наименьшее

```
          1+6
          1+3
         3   6 
       2   4   6
     1   2   3   4
```

Ну и итогом получаем вот такой треугольник:

```
           4
         3   6 
       2   4   6
     1   2   3   4
```

Теперь в вершине лежит число, которое и является самым дешевым спуском. Нам больше ничего искать не надо, мы можем сразу дать ответ. 

Данное решение хорошо еще тем, что мы можем вообще не модифицировать исходный треугольник, если добавим список, размером `h`, где `h` высота треугольника. В данном списке мы как раз будем хранить накапливающуюся сумму. Итогом мы не изменим исходных данных и получим ответ.

Решение с изменением исходных данных:
```python
class Solution:
    def minimum_total(self, triangle: list[list[int]]) -> int:
      # итерируемся по строкам начиная с предпоследней
      # и поднимаясь вверх
      for row_index in range(len(triangle) - 2, -1, -1):
        # берем каждый элемент текущей строки
        for i in range(len(triangle[row_index])):
          # находим левое и правое число,
          # которое лежит под текущим
          left_child = triangle[row_index + 1][i]
          right_child = triangle[row_index + 1][i + 1]
          # выбираем меньшее из чисел
          triangle[row_index][i] += min(left_child, right_child)
      # ответ находится на вершине, его уже не надо искать
      return triangle[0][0]
```

Решение без изменения исходных данных:
```python
from copy import deepcopy


class Solution:
    def minimum_total(self, triangle: list[list[int]]) -> int:
      # копируем последнюю строку
      result_counter = deepcopy(triangle[-1])

      # итерируемся по строкам начиная с предпоследней
      # и поднимаясь вверх
      for row_index in range(len(triangle) - 2, -1, -1):
        # берем каждый элемент текущей строки
        for i in range(len(triangle[row_index])):
          # находим левое и правое число,
          # которое лежит под текущим
          left_child = result_counter[i]
          right_child = result_counter[i + 1]
          current_element = triangle[row_index][i]
          # выбираем меньшее из чисел
          result_counter[i] = current_element + min(left_child, right_child)
      # ответ находится на первой позиции, его уже не надо искать
      return result_counter[0]
```

Итогом мы получим ответ и не изменим входные данные. При этом дополнительной памяти мы возьмем `O(h)`, где `h` это высота треугольника(`len(triangle)`).

---
PS:
Спасибо что дочитали. Очень большой разбор вышел, так как хотелось передать именно то, как идет мысль в решении данных задач. Важно раскручивать клубок от минимального понимания в сторону понятных вещей. После чего мысль может превратиться в понятное и простое решение.