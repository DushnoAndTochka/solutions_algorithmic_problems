# Longest Palindromic Substring Solution

## Описание

Ключем для решения данной задачи будет понимание ответа на вопрос:
- Как понять, что какая-то строка - палиндром ?

Есть два стандартных способа сделать это

1. Поставить два указателя по краям строки и начать двигаться к ее середине. Если в какой то момент указатели окажутся на разных буквах, то это не палиндром. 

2. Поставить два указателя на центр и начать двигаться от центра к раям. Если в какой то момент указатели окажутся на разных буквах, то это не палиндром. До начала движения необходимо определить четность сдлины строки. Это важно для выставления указателей. Пример ниже
    ```
    left
      |
      V
    tennet
       ^
       |
      right

    
    left
      |
      V
     LOL
      ^
      |
     right
    ```
    Те в четном случае стартуют с соседних букв, а в случае не четности с одной буквы.


## Решение от краев к центру

Давайте порассуждаем над первым способом в рамках нашей задачи. Как юы мы могли его применить ? 

С левым указателем нет никаких проблем. Мы интерируемся по изначальной строке и каждый новый элемент будет считаться `левым`. НО где взять правый ? любой символ после `левого`, может оказаться крайним правым для палиндрома.

левый/правый/правее левого -_- запутались ?

```
left
 |
 V
 aaaaaaaaaaaaa
```

Вот какая-то строка. Для начала предположим, что первый символ является `левой` границей для палиндрома. Что брать в качестве правой границы ? В данном случае что угодно, все равно палиндром.

То есть, нам надо взять левый символ и проверить все варианты правой границы, ведь любоя буква после `левой`, может оказаться `правой` границей для палиндрома. Думаю на этом уже понятно, что асимптотическая сложность становится просто не вероятно большой. Но таким образом и правда можно решить задачу, правда не очень эффективное решение получится.

## Решение от центра к краям

Давайте порассуждаем о втором варианте решения. Нам надо взять любую букву и предположить, что именно она является центром палиндрома. Начать двигаться от нее к краям, что проверить предположение. Даже звучит гораздо легче чем предыдущее. Какой план ?
- Мы идем по изначальной строке и берем каждую букву. 
- предполагаем, что именно она является центром самого большого палиндрома.
- Проверяем эту теорию.
- Профит

Но не стоит забывать, что палиндромы бывают четными и не четными по длине(читаем выше. уже писал об этом). В таком случае стоит в лоб проверить два разных сценария для каждой буквы. То есть мы предполагаем, что вокруг буквы образовался палиндром не четной длинны и проверяем. После предполагаем, что вокруг все той же буквы образовался четный палиндром и следующая буквы является парой центру. Выходит что на каждую букву у нас всего две проверки. Как это выглядит ?

```python
class Solution:
    def longest_palindrome(self, s: str) -> str:
        # выставляем два указателя на будущий
        # результирующий отрезок 
        # s[result_start_pos:result_stop_pos]
        result_start_pos = 0
        result_stop_pos = 1

        # идем по строке и делаем предположение,
        # что символ является серединой палиндрома
        for i in range(len(s)):
            # создаем цикл для четного и не четного варианта. 
            # В описании, с визуализацией указателей для этих
            # случаев, видно, что отличие всего на одну
            # позицию для правого указателя.
            for right in [1, 2]:
                # левый выставляем на текущую букву
                left = i
                # ставим на следующую букву, для проверки 
                # четного варианта
                # ИЛИ через одну правее для нечетного варианта
                right += i

                # пока не вышли за границы и букву на правом
                # и левом указатели равны, все отлично и
                # мы двигаем указатели дальше
                while left >= 0 and right < len(s) and s[left] == s[right]:
                    left -= 1
                    right += 1

                # смотрим не оказался ли новый подотрезок больше,
                # чем тот что уже в памяти. Вдруг мы нашли новый,
                # самый длинный палиндром.
                if (right - left - 1) > (result_stop_pos - result_start_pos):
                    result_start_pos = left + 1
                    result_stop_pos = right

        return s[result_start_pos:result_stop_pos]
```
