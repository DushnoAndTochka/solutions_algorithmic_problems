# Subsets


## Решение 1

Первое решение которое можно придумать, это взять все комбинации разных длин.

То есть для массива `[1,2,3]` все комбинации длины 2 будут `[(1, 2), (1, 3), (2, 3)]`
А длины 1 `[(1,), (2,), (3,)]`

Но в itertools уже есть функция, которая возвращает все комбинации и можно ей воспользоваться


```python

import itertools


class Solution:
    def subsets(self, nums: list[int]) -> list[tuple[int]]:
        # Можно не находить все комбинации нулевой длины 
        # и длины массива
        r = [(), tuple(nums)]
        
        # В цикле добавляем к результату все комбинации
        for i in range(1, len(nums)):
            r.extend(itertools.combinations(nums, i))
        # Возвращаем результат
        return r
```

## Решение 2

Но можно не пользоваться модулей itertools и решить данную задачу рекурсивно.

Но мы будем использовать генераторы

```python

class Solution:

    def subsets(self, nums: list[int]) -> list[tuple[int]]:
        # Возвращаем просто все элементы из генератора
        return list(self._subsets(nums, [], 0))

    def _subsets(self, nums: list[int], item: list[int], i: int):
        # Если индекс больше длины, то добавляем элемент и возвращаем значение
        if i >= len(nums):
            yield tuple(item)
            # Тут return очень важен, так как не нужно больше ничего делать, 
            # если i больше len(nums) 
            return
        
        # Добавляем элемент под индексом i
        item.append(nums[i])
        # Вызываем функцию рекурсивно с i+1
        yield from self._subsets(nums, item, i + 1)
        # Удаляем последний элемент - это будет, тот который мы добавили
        item.pop()
        # Вызываем функцию рекурсивно с i+1
        yield from self._subsets(nums, item, i + 1)
```


Этот алгоритм будет работать, так как нужно вернуть все возможные subsets со всеми возможными удалениями.

А мы что добавляем элемент, вызываем рекурсивно метод, потом удаляем этот элемент и так же вызываем рекурсивно наш метод.

И в таком случае мы получим все subsets в которых есть этот элемент и в которых его нет.

И так будет с каждым элементом и мы получим как раз то что хотели.
