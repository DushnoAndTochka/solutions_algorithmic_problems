# MedianOfTwoSortedArrays Solution

## Описание

> Решение, которое придумал, вышло достаточно сложным. Уверен что есть проще. Если знаете, то делайте ПР.

Начнем с простых вещей. У нас есть два отсортированных массива и надо вернуть их медиану. 

Простой способ достичь этого, сложить их и просто посмотреть что там в середке. Но складывание массивов, даже отсортированных, выполнится не быстрее чем `O(n+m)`. Не можем же мы положить элемент, не "потрогав" его.

Выходит что ответ где то перед носом, но его надо выковырять...

Давайте рассматривать разные сценарии.

### Сценарии

1. К нам приходит один пустой, а воторой заполненный.
    ```python
    nums1: []
    nums2: [1, 2, 3]
    ```
    Тут сразу понятно, что нам просто надо забыть про пустой и найти середку у второго.

2. К нам пришли два массива, которые отсортированны друг по отношению к другу.
    ```python
    nums1: [1, 2, 3, 4]
    nums2: [5, 6, 7, 8]
    ```
    Тоже легко решаемая задача. Нам остается только посчитать какие числа будут в середине. Сделать не сложно.
    ```python
    middle: (len(nums1) + len(num2)) // 2
    ```
    Если четное, то надо прихватить друга соседа.

3. Теперь крайний сценарий. К нам приходят любой другой сценарий.
    ```python
    nums1: [1, 3, 5, 7]
    nums2: [2, 4, 6, 8]
    ```
    Тут посложнее.
    
    Надо понять несколько вещей, что бы дать ответ.
    - Что бы мы делали, если бы могли склеить этот массив ?
        
        Нашли бы середину и быстро дали ответ =)
    - А что такое середина и можем ли мы без нее ?

        Середина, это когда и справа и слева одинаковое кол-во элементов. А для медианы это еще и главное правило.

    Из воторого следует, что у нас слева и справа одинаковое кол-во элементов от медианы
    ```
    [1, 2, 3, 4, 5, 6, 7, 8]
       <-----      ------>       
         3    ^  ^    3
              |  |
             mediana 
    ```
    Для нечета будет тоже самое. Справа и слева одно и тоже. Назовем это число `count_to_right_of_median` и будем работать именно с правым. 

    Как работать ? Да все ж просто. Получается нам не надо искать никакой середины =) Нам надо найти число, справа от которого строго `count_to_right_of_median` элементов. Если мы сможем найти такое число, то мы найдем и середину. Ниже распишу как это сделать.


### Как искать число ?

Продолжим думать как искать такое число. Можно попробовать за линию его найти, это же не сложно ? просто надо сделать `count_to_right_of_median` сравнений =) МНОГО... нам столько нельзя по условию.

В задании фигурирует логарифм, а значит пахнет бинарным поиском. Осталось придумать как его тут использовать.

Да и тут не сложно, мы же легко можем понять с чем сравнивать число и подходит ли оно нам. Есть несколько правил, которые это определяют.

- Справа от числа должно быть `count_to_right_of_median` элементов. Ну и что спросите вы ? Если мы возьмем любое число из первого списка, то мы можем сказать сколько справа от него элементов.
    ```
    [1, 2, 3, 4, 5]
        ^
        |
    правее 3 числа
    ```
    Выходит, что если мы знаешь сколько всего должно быть правее и сколько сейчас, то мы можем посчитать, сколько `надо` добавить, что бы это был ответ.

    ```
    nums1: [1, 3, 5]
    nums2: [2, 4, 6]

    All: 6 elem
    count_to_right_of_median: 2
    ```

    Те у нас `6` элементов, `2` элемента в середине и `2` по краям.

    Если мы возьмем `3`, то у него есть `5` правее. значит если он находится в середине(предположим), то ему не зватает еще одного элемента. Значит давайте попробуем `вставить` его во второй массив так, что бы справа от него был 1 элемент и список не перестал быть отсортированным.

    ```
    nums2: [2, 4,  6]
                 ^
                 |
                 3
    ```
    Понятно что он не может туда встать, ведь тогда список перестанет быть отсортированным. `3 < 6`, НО `3 < 4`. От сюда появляется следующее правило

- Справа от места вставки должно быть число больше или равное текущема, а слева меньше или равное.

То есть если мы найдем такое число которое сможем вставить в другой массив и выполнить условия выше, то мы нашли наш ответ.

## Пример того как это работает.
Начнем с простого варианта

На вход подается следующее

```python
nums1: [1, 3, 5, 7, 9]
nums2: [2, 4, 6, 8, 10]
```

Определяем общую длину, она равна 10. Значит у нас четная ситуация и необходимо найти 2 числа в середине.

`(10 - 2) // 2 == 4 -> count_to_right_of_median`. То есть от правого числа медианы должно находиться 4 числа.

```
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
             ^  ^
             |  |   <-------->
            mediana   4 числа
```
Мы берем первый массив и начинаем работать с ним при помощи бинарного поиска. Правая граница выставляется на самое последнее число, а вот левая выставляется на `5` справа число.
> Тут необходимо объяснить. Так как нам нужно число, справа от которого находится ровно 4 числа. то ставить левую границу в самое начало, не рационально, так как они все заведомо ложные и не подойдут нам(правее них слишком много чисел в самом начале).

В данном примере левая граница упадет на самое первое число, но это только в этом примере, дальше будет еще один.

```
                middle
                  |  <------>
                  v   2 числа
nums1: [1,   3,   5,   7,   9]
       ^                    ^
       |                    |
       LP                   RP
```

Расставили все основные указатели. Мы видим что средним является `5`, и правее от нее есть еще два числа. Предположим, что она является медианой для объединенного массива. Значит после `слияния` правее нее должно быть `4` числа. (см. `count_to_right_of_median`). Выходит, что мы можем проверить, если помести 5 во второй массив так, что бы правее нее оказалось еще два числа, что в сумме даст нам `count_to_right_of_median`, то справа от нее должно быть число больше, а слева меньше. Если это условие выполнится, то мы победили.

```
nums1:    [1,   3,   5,   7,   9]
                     |
                     v
nums2: [2,   4,   6,    8,   10]
```
Как мы видим, она не может быть вставлена туда так, что бы выполнялись все условия. Значит `5` не является правой границей медианы(там два числа). 

Так как `6 > 5 < 8`, то стоит попробовать взять число побольше, ведь у нас есть прямая зависимость числа из первого массива и места вставки и она обратная. То есть чем левее мы берем число у первого, тем правее оно будет помещаться во второй и наоборот(число элементов справа от выбранного всегда одинаково и если его увеличивать в первом, то оно уменьшится во втором). Значит если взять число левее текущего, помним что массив отсортирован и левее все числа меньше, то мы гарантированно не выполним условие. Значит двигаемся вправо.

```
                     middle
                       |  <-->
                       v   1 число
nums1: [1,   3,   5,   7,   9]
                       ^    ^
                       |    |
                      LP    RP
```

Тем к нам попалась `7`. Попробуем сделать все тоже самое и с ней.


```
nums1: [1,   3,   5,   7,   9]
                       |
                       v
nums2:        [2,   4,    6,   8,   10]
```

Как видим `7` попытается встать между `4` и `6`. Думаю вы уже догадались, что нас такое не устроит, так как будут нарушены правила.

Теперь у нас отличная картина `4 < 7 > 6`. Наша серединка больше любого числа в месте вставки. Значит мы взяли слишком большое число и правую границу надо двигать за середину.

Тут становится понятно, что у нас каретки разошлись. Возникает вопрос, что теперь ? Да все просто. меняем местами `nums1` и `nums2` и делаем все тоже самое =) Просто правая граница медианы, лежит не в этом массиве.


```
                middle
                  |  <------>
                  v   2 числа
nums2: [2,   4,   6,   8,   10]
        ^                   ^
        |                   |
        L                   RP
```
Начинаем все сначала. Теперь серединка на `6`. Попробуем ее вставить.


```
nums2:    [2,   4,   6,   8,   10]
                     |
                     v
nums1: [1,   3,   5,    7,   9]
```
И нам повезло. `6` спокойно может быть сюда помещена. Она выполняе условие `5 <= 6 <= 7`. Значит правая граница найдена!

НО мы помним что у нас четная история, а в ней, при расчете медианы, участвуют два числа. Мы нашли правое, теперь надо понять какое левое... Могло показаться, что прийдется еще раз делать все тоже самое. Но это не так. Левее `6` может быть всего лишь два числа, либо `4`, которая прямо из входных данных находится левее, либо левое число относительно места вставки `5`. Какое выбрать ? То что больше, ведь к 6 попадет именно то, что больше, так как слитый массив тоже отсортирован.

Значит ответ будет `(5 + 6) / 2 => 5.5`

# PS
Это основная мысль, все остальное уже краевые случаи. Не стал расписывать вообще все решение, так как там еще много тонкостей. Надеюсь сама идея понятна. Спасибо что дочитали до сюда =) У вас все получится !!!