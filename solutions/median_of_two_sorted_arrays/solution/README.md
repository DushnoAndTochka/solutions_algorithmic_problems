# MedianOfTwoSortedArrays Solution

## Описание

> Решение, которое придумал, вышло достаточно сложным. Уверен что есть проще. Если знаете, то делайте ПР.

Начнем с простых вещей. У нас есть два отсортированных массива и надо вернуть их медиану. 

Простой способ достичь этого, сложить их и просто посмотреть что там в середке. Но складывание массивов, даже отсортированных, выполнится не быстрее чем `O(n+m)`. Не можем же мы положить элемент, не "потрогав" его.

Выходит что ответ где то перед носом, но его надо выковырять...

Давайте рассматривать разные сценарии.

### Сценарии

1. К нам приходит один пустой, а воторой заполненный.
    ```python
    nums1: []
    nums2: [1, 2, 3]
    ```
    Тут сразу понятно, что нам просто надо забыть про пустой и найти середку у второго.

2. К нам пришли два массива, которые отсортированны друг по отношению к другу.
    ```python
    nums1: [1, 2, 3, 4]
    nums2: [5, 6, 7, 8]
    ```
    Тоже легко решаемая задача. Нам остается только посчитать какие числа будут в середине. Сделать не сложно.
    ```python
    middle: (len(nums1) + len(num2)) // 2
    ```
    Если четное, то надо прихватить друга соседа.

3. Теперь крайний сценарий. К нам приходят любой другой сценарий.
    ```python
    nums1: [1, 3, 5, 7]
    nums2: [2, 4, 6, 8]
    ```
    Тут посложнее.
    
    Надо понять несколько вещей, что бы дать ответ.
    - Что бы мы делали, если бы могли склеить этот массив ?
        
        Нашли бы середину и быстро дали ответ =)
    - А что такое середина и можем ли мы без нее ?

        Середина, это когда и справа и слева одинаковое кол-во элементов. А для медианы это еще и главное правило.

    Из воторого следует, что у нас слева и справа одинаковое кол-во элементов от медианы
    ```
    [1, 2, 3, 4, 5, 6, 7, 8]
       <-----      ------>       
         3    ^  ^    3
              |  |
             mediana 
    ```
    Для нечета будет тоже самое. Справа и слева одно и тоже. Назовем это число `count_to_right_of_median` и будем работать именно с правым. 

    Как работать ? Да все ж просто. Получается нам не надо искать никакой середины =) Нам надо найти число, справа от которого строго `count_to_right_of_median` элементов. Если мы сможем найти такое число, то мы найдем и середину. Ниже распишу как это сделать.


### Как искать число ?

Продолжим думать как искать такое число. Можно попробовать за линию его найти, это же не сложно ? просто надо сделать `count_to_right_of_median` сравнений =) МНОГО... нам столько нельзя по условию.

В задании фигурирует логарифм, а значит пахнет бинарным поиском. Осталось придумать как его тут использовать.

Да и тут не сложно, мы же легко можем понять с чем сравнивать число и подходит ли оно нам. Есть несколько правил, которые это определяют.

- Справа от числа должно быть `count_to_right_of_median` элементов. Ну и что спросите вы ? Если мы возьмем любое число из первого списка, то мы можем сказать сколько справа от него элементов.
    ```
    [1, 2, 3, 4, 5]
        ^
        |
    правее 3 числа
    ```
    Выходит, что если мы знаешь сколько всего должно быть правее и сколько сейчас, то мы можем посчитать, сколько `надо` добавить, что бы это был ответ.

    ```
    nums1: [1, 3, 5]
    nums2: [2, 4, 6]

    All: 6 elem
    count_to_right_of_median: 2
    ```

    Те у нас `6` элементов, `2` элемента в середине и `2` по краям.

    Если мы возьмем `3`, то у него есть `5` правее. значит если он находится в середине(предположим), то ему не зватает еще одного элемента. Значит давайте попробуем `вставить` его во второй массив так, что бы справа от него был 1 элемент и список не перестал быть отсортированным.

    ```
    nums2: [2, 4,  6]
                 ^
                 |
                 3
    ```
    Понятно что он не может туда встать, ведь тогда список перестанет быть отсортированным. `3 < 6`, НО `3 < 4`. От сюда появляется следующее правило

- Справа от места вставки должно быть число больше или равное текущема, а слева меньше или равное.

То есть если мы найдем такое число которое сможем вставить в другой массив и выполнить условия выше, то мы нашли наш ответ.

# PS
Это основная мысль, все остальное уже краевые случаи. Не стал расписывать вообще все решение, так как там еще много тонкостей. Надеюсь сама идея понятна. Спасибо что дочитали до сюда =) У вас все получится !!!