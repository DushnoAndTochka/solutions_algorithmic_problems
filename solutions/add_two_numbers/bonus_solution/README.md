# AddTwoNumbers Bonus Solution

Идея полностью схожа с решением в "solution". Это решение является копией того, только inplace. То есть в этом решении мы не будем создавать новых нод, а будем модифицировать имеющиеся и вернем в ответе ссылку на голову одного их пришедших списков(того кто побольше окажется или первого).

В момент когда мы посчитаем суммы в текущем разряде, мы положим ее сразу ноды этого же разряды списков, которые пришли. То есть мы перепишем пришедшие списки и будем складывать прям в них то, что насчитали.

## Как это выглядит ?

```
l1: 1 -> 2 -> 3 -> 4 -> None
l2: 5 -> 6 -> 7 -> 8 -> None

# result == l1_head
result: 1 -> 2 -> 3 -> 4 -> None
member_num = 0
```

- ### 1 Шаг:
    ```
    l1: 2 -> 3 -> 4 -> None
    l2: 6 -> 7 -> 8 -> None

    # result == l1_head
    result: 6 -> 2 -> 3 -> 4 -> None
    member_num = 0
    ```

- ### 2 Шаг:
    ```
    l1: 3 -> 4 -> None
    l2: 7 -> 8 -> None

    # result == l1_head
    result: 6  -> 8 -> 3 -> 4 -> None
    member_num = 0
    ```

- ### 3 Шаг:
    ```
    l1: 4 -> None
    l2: 8 -> None

    # result == l1_head
    result: 6 -> 8 -> 0  -> 4 -> None
    member_num = 1
    ```

- ### 4 Шаг:
    ```
    l1: None
    l2: None

    # result == l1_head
    result: 6 -> 8 -> 0  -> 3 -> None
    member_num = 1
    ```

```
l1_head: 6 -> 8 -> 0 -> 3 -> 1 -> None
l2_head: 6 -> 8 -> 0 -> 3 -> None

answer: 6 -> 8 -> 0 -> 3 -> 1 -> None
```
Так как списки оказались одной длинны, то мы выбрали первый и добавили в него новый разряд.
Если бы списки оказались разной длины, то мы выбрали бы больший и он бы стал результирующим

# Важно
Данное решение изменяет входные данные! Чаще всего это очень плохая практика и использовать подобные подходы опасно. Поэтому подумайте пару раз, прежде чем написать что-то подобное. НО оно не создает новых объектов в памяти, так что оно явно оптимальней.