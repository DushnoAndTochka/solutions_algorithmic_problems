# Unique Paths Solution

# Описание

Начнем с простого, что выводится из условия. Так как робот может двигаться только вправо или вних, то в лубую клетку мы можем попасть либо сверху, либо слева. Итого только из двух соседних клеток, можно попасть в какую бы то ни было клетку. Это необходимо понять и запомнить.

Предположим что у нас есть вот такое поле

```
---------------------------------
| R |   |   |   |   |   |   |   |
---------------------------------
|   |   |   |   |   |   |   |   |
---------------------------------
|   |   |   |   |   |   |   | F |
---------------------------------
```

Если подумать, то в любую клетку верхнего уровня, мы можем попасть только одним способ. Если робот будет двигаться постоянно вправо. Ветвлений для попадания в них попросту не существует. 
>Речь идет именно о количествах способов попадания в конкретную клетку

Такая же история с левой гранью, давайте заполним эти данные.

```
---------------------------------
| R | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
---------------------------------
| 1 |   |   |   |   |   |   |   |
---------------------------------
| 1 |   |   |   |   |   |   | F |
---------------------------------
```

Теперь, зная что в любую клетку можно попасть только сверху или снизу, мы можем начать заполнять остальные. Чем то будет напоминать таблицу умножения/сложения. То есть количество спобов, которыми мы можем оказаться в какой-то клетке, равно сумме способ попасть в `левую` и `верхнюю` клетки от текущей.

```
---------------------------------
| R | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
---------------------------------
| 1 | 2 |   |   |   |   |   |   |
---------------------------------
| 1 |   |   |   |   |   |   | F |
---------------------------------
```

В ближайшую клетку по диагонали от робота, можно попасть всего двумя способами. Либо робот шагнет `вправо и вниз`, либо `вниз и вправо`. Больше нет вариантов никаких. Тоже самое касается всего поля. Мы можем итеративно заполнять каждую клетку слой за слоем.

```
---------------------------------
| R | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
---------------------------------
| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
---------------------------------
| 1 |   |   |   |   |   |   | F |
---------------------------------
```

Вот так будет выглядеть картина, еси заполнить первый слой. Те в крайнюю правую клетку второго уровня, можно попасть 8 способами, больше нет вариантов. Остается добить третий уровень и получить ответ

```
---------------------------------
| R | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
---------------------------------
| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
---------------------------------
| 1 | 3 | 6 | 10| 15| 21| 28| F |
---------------------------------

Ответ: 28 + 8 = 36
```

Надеюсь идея ясна. Решение будет выглядить приблизительно так:

```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        # сразу заполняем первый уровень единицами
        res = [1] * n
        
        # создаем цикл на 1 меньше,
        # так как первый уровень уже заполнен
        for _ in range(m-1):
            # начинаем не с 0,
            # так как левая граница всегда равна 1
            for i in range(1, n):
                # начинаем заполнять. В каждом индексе,
                # который не прошли на этом уровне,
                # лежит число с предыдущего уровня,
                # то есть число, которое сверху текущего.
                # Остается сложить его с число,
                # которое идет предыдущим и получим
                # текузее щначение.
                res[i] += res[i-1]
                
        # после всех работ в последнем
        # индексе будет лежать результат
        return res[-1]
```

В целом это уже вполне приемлемое решение. Но можно заметить что-то еще и свести решение к одной формуле.

### Решение через комбинаторику:

Надо понять одну особенность. Что бы попасть от старта к финишу, нам необходимо `обязательно` преодолеть `N-1` клеток по горизонтале и `M-1` клеток по вертикале. Невозможно иным способом попасть от старта к финишу. Значит что бы нам попасть к финишу, нам необходимо преодолеть `M + N - 2` клетки разными способами. С этим разобрались.

Теперь давайте представим путь как прямую и пронумеруем все клетки от старта до финиша:

```
-------------------------
| R |   |   |   |   |   |
-------------------------
|   |   |   |   |   |   |
-------------------------
|   |   |   |   |   | F |
-------------------------

---------------------------------
| R | 1 | 2 | 3 | 4 | 5 | 6 | F |
---------------------------------
```

Если не понятно что это за прямая. Данная прямая отображает `любой` путь от начала до конца. Как мы выяснили ранее, его длина составит `M + N - 2`.

Теперь нам необходимо выбрать две любые клетки в которых мы сделаем шаг вних, так как финишь находится на два уровня ниже от старта. Получим например такой маршрут

```
-------------------------
| R | 1 | 2 | 3 |
-------------------------
            | 4 | 5 |
-------------------------
                | 6 | F |
-------------------------
```

Таким образом, если мы будем выбирать постоянно две любые клетки и не повторяться, то мы получим все возможные пути. Те кто знакомы с комбинаторикой уже поняли к чему я веду. Есть прекрасная формула `число сочетаний из n по k`, которая позволяет посчитать все комбинации раставить `k` уникальных элементов в `n` ячеек не повторяясь. Это естественно грубое определение, но смысл оно передает. И нам эта формула подходит идеально, ведь нам необходимо выбрать `M - 1` уникальные ячейки всеми в `M + N - 2` вариантах и не повторяться.

Формула выглядит следующим образом:

```
n - уникальных объектов
k - надо раставить не повторяясь 

n! / (n−k)!⋅k!
```

Но питон позволяет использовать библиотечную ф-цию `math.comb`. Таким образом мы получаем такое решение:

```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        return math.comb(m+n-2, m-1)
```

К слову. Решение будет справедливо не только к `m-1`, но и к `n-1`, так как тогда мы будем искать способы сдвинуть ячейки не вниз, а вправо и разницы никакой не будет. То есть и такое решение выдаст такой же результат:

```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        return math.comb(m+n-2, n-1)
```

# PS
Спасибо что дочитали до самого конца. 
В очередной раз стоит понять, что перед реением необходимо взять листочек и порисовать на нем различные варианты и идеи, тогда получится придумать не плохое решение.