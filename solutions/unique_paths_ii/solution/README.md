# Unique Paths II Solution

> Решение, которое тут описано, построено на решении похожей задачи. а именно [Unique Paths](/solutions/unique_paths/solution/)

## Описание

Решение почти ни чем не отличается от решения первой версии данной задачи, где отсутствовали камни(преграды).

Вспоминаем основной тезис решения той задачи. В любую клетку, кроме верхних и лево-боковых, можно попасть всего двумя способами, либо с верхней клетки, либо с левой клетки. Получается что кол-во способов, которым мы можем достич любой клетки, равно кол-во способов попадания в верхнюю над ней или в левую от нее. 

ЭТО правило справедливо и для этой задачи.

Второе важное, что в любую верзнюю мы можем попасть только одним способом, двигаясь постоянно в право. Такая же история и с левой гранью, но там постоянно движение вниз. 

ЭТО правило претерплео изменения. Если встретится камень(препятствие), то мы уже никак не сможем двигаться по этой линии. А значит все остальные клетки, за клеткой с препятствием, становятся недостижимы и кол-во способов туда попасть будет равно нулю.

Пример

```
---------------------------------
| R | 1 | 1 | 1 | S | 0 | 0 | 0 |
---------------------------------
| S |   |   |   |   |   |   |   |
---------------------------------
| 0 |   |   |   |   |   |   | F |
---------------------------------

R - робот
F - финишь
S - камень
```

В изначальной задачи верх всегда был в единицах, как и левый край. Теперь чутка поменялось из-за препятствий.

В остальном решение тоже самое. Встретил камень ? значит эта клетка имеет 0 способов попадания, так как мы на нее не можем попросту наступить. В остальных случаях складываем кол-во способов двух клеток, над текущей, левее текущей и получаем результат. 

ВАЖНО! Если по левой гране встретился камень, то все клетки ниже будут равны не 1, а 0 с этого момента.


```python
class Solution:
    def unique_paths_with_obstacles(
            self, obstacle_grid: list[list[int]]) -> int:
        # если препятствие на 0 позиции,
        # то больше нечего проверять
        if obstacle_grid[0][0] == 1:
            return 0

        # создаем массив, который будет хранить суммы
        result = [0] * len(obstacle_grid[0])
        for i in range(len(obstacle_grid[0])):
            # первая строка не стандартна и может
            # содержать препятствия; пытаемся
            # их найти и если нашли,
            # то оставляем все остальное с нулями,
            # ведь туда невозможно попасть
            if obstacle_grid[0][i] == 1:
                break
            result[i] = 1

        for i in range(1, len(obstacle_grid)):
            # убеждаемся, что левая грань не имеет
            # преград и по ней возможно пройти;
            # Если на любом из предыдущих уровнях
            # была встречена преграда,
            # то ниже идти невозможно
            if result[0] and obstacle_grid[i][0]:
                result[0] = 0
            for j in range(1, len(obstacle_grid[i])):
                if obstacle_grid[i][j] == 1:
                    # встретили преграду ?
                    # значит в эту клетку невозможно наступить
                    result[j] = 0
                else:
                    # нет преград, значит суммируем кол-во
                    # способов попадания в верхнюю и в
                    # левую клетки от текущей.
                    result[j] = result[j] + result[j - 1]

        return result[-1]
```

Решение почти такое же как и в предыдущей версии и отличается очень слабо. Может возникнуть вопрос, почему я использую массив, а не матрицу второго порядка ? Тут маленькая хитрость. В предыдущем элементе ВСЕГДА хранится сумма уже текущего уровня, а вот в текущей элементе хранится значение еще с предыдущего уровня, который мы не успели пересчитать. Поэтому мы как бы пересчитываем прям на месте и экономим память.