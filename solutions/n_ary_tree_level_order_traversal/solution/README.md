# N-ary Tree Level Order Traversal

Задачку можно решить следующим образом

- Проходимся по всем элементам уровня
- Формируем следующий уровень
- Добавляем все элементы данного уровня в результат
- Проделываем тоже самое для следующего уровня


```python
class Solution:
    def level_order(self, root) -> list[list[int]]:
        result = []
        # Если корня нет, то возвращаем пустой список
        if root is None:
            return result
        # Первый уровень состоит только из корня
        level = [root]
        # Проходимся по всем уровням, пока там есть элементы
        while level:
            # Добавляем в результат список содержащей все элементы данного уровня
            result.append([i.val for i in level])
            
            # Формируем следующий уровень
            next_level = []
            for i in level:
                # Добавляем всех детей в следующий уровень
                next_level.extend(i.children)
            # Заменяем следующий уровень на текущий 
            level = next_level
        # Возвращаем результат
        return result
```

Давайте разберем сложность полученного алгоритма.

Мы можем заметить то что мы делаем константное количество операций для каждой ноды, поэтому сложность по времени зависит от
количества нод - то есть O(N).

А теперь разберем по памяти.
В результате у нас все ноды - то есть O(N). Так же мы используем временные массивы, которые могут содержать не больше количества нод элементов.

Поэтому сложность по памяти у нас так же O(N).