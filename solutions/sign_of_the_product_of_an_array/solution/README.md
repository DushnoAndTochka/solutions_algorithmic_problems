# SignOfTheProductOfAnArray Solution

## Описание

Задача имеет несколько отличных решений. Решения являются развитием друг друга, поэтому пойду от худшего.

### Решение в лоб

Тут ничего хитрого. Что нам надо, что бы дать ответ ? Посчитать произведение всех чисел и сказать положительное оно или отрицательное. Значит так и поступим.

```python
class Solution:
    def array_sign(self, nums: List[int]) -> int:
        p = 1
        for num in nums:
            p *= num

        return self.sign_func(num)

    @staticmethod
    def sign_func(num: int) -> int:
        if num < 0:
            return -1

        return num > 0
```

Все как и просили. Считается произведение. Используется какая-то вспомогательная ф-ция и отвечает по условию. Все отлично ? Конечно нет... Если присмотреться к ф-ции `array_sign`, то станет понятно, что она возвращает одно из `-1 0 1`. Тогда:
- зачем мы вообще накапливаем произведение всех чисел ?
- зачем нам какая-то вспомогательная ф-ция ?

Об этом в следующем решении.

### Решение через четность суммы отрицательных.

В предыдущем решении мы поняли, что считать все произведение нет смысла, нам достаточно понять является ли результирующее число отрицательным или равным 0, во всех остальных случаях оно положительное.

Произведение чисел будет равно нулю, если одну из чисел в проихведении было равно `0`. Тут думаю ничего сложного.

Произведение чисел будет отрицательным, если кол-во отрицательных множителей нечетное. Вот тут возможно прийдется пару раз перечитать предыдущее предложение, хотя оно очень даже логичное. Мы знаем следующее:
- Если отрицательное умножить на отрицательное, то получим положительное.
- Если положительное умножить на отрицательное, то получим отрицательное.

Это основная идея. То есть нам не важно сколько там всего чисел, чему равно их произведение. Нам инетересно что если отрицательных нечетное кол-во, то результат будет отрицательным, иначе положительным(так же помним про ноль).

```python
class Solution:
    def array_sign(self, nums: List[int]) -> int:
        negativ_counter = 0

        for num in nums:
            if num == 0:
                # больше нечего считать. Ответ ноль.
                return 0
            if num < 0:
                negativ_counter += 1

        # проверим результат на четность и вернем ответ.
        return 1 if negativ_counter % 2 == 0 else -1
```

Уже радует, что нам не приходится накапливать произведение чисел, которое не используется позже. Теперь все отлично ? Ну не совсем, иожно улучшить. Что не нравится ? Не нравится деление, ведь можно и проще.

### Решение через игру с знаком.

> Это решение является продолжением идеи предыдущего. Все правила, которые были там описаны, будут использоваться и тут.

Как же можно улучшить ? А зачем нам вообще считать четность и делить что-то ? нам ведь просто надо ответить `1` для четного сценария и `-1` для не четного. При этом есть правило, которое описал раньше:
- Если отрицательное умножить на отрицательное, то получим положительное.
- Если положительное умножить на отрицательное, то получим отрицательное.

От сюда появляется следующее решение.

```python
class Solution:
    def array_sign(self, nums: List[int]) -> int:
        result = 1

        for num in nums:
            if num == 0:
                # ни чего не поменялось.
                return 0

            if num < 0:
                # встретили отрицательное, значит меняем знак у результата.
                result = -result

        return result
```

Начало очень схоже, но теперь мы меняем знак у результата каждый раз, когда встречаем отрицательное число.

## PS
Важно понимать, что все решения имеют линейную сложность выполнения O(n). По памяти они все так же одинаковы и равны константе O(1).
