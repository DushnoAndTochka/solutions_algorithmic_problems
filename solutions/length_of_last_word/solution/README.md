# LengthOfLastWord Solution

Данная задача имеет массу около одинковых решений за O(n), где n это длина входящий строки.

- ### Решение через **Split**:
    Ничего хитрого. Через сплит разбиваем строку на множество "слов". Берем последнее слово и смотрим его длину
    ```python
    def length_of_last_word(s: str) -> int:
        return len(s.split(' ')[-1])

    assert length_of_last_word("Hello world") == 5
    ```
    
    **Плюсы**
    - Решение очень короткое и понятное.

    **Минусы**
    - Решение выделяет память, которая нам никогда не понадобится. Если в строке окажется 10000 слов, то нам прийдется создать множество из 10000 элементов и создать 10000 строк, а для ответа нужен только последний.
    - Решение зависит от длины строки.

- ### Решение через **Strip**:
    В предыдущем решении мы поняли, что нам нет большой нужды "трогать" все слова в строке. Нам нужно взаимодействовать только с последним словом этой строки, но перед ним могут идти пробелы в любом кол-ве и их считать не надо. Вспоминаем про ф-цию strip, которая умеет отрезать пробелы слева и справа у строки. 
    ```python
    def length_of_last_word(s: str) -> int:
        s = s.strip()
        answer = 0
        for i in range(len(s) - 1, -1, -1):
            if s[i] == " ":
                return answer
            answer += 1
        return answer

    assert length_of_last_word("Hello world    ") == 5
    ```

    **Плюсы**
    - Решение понятное.
    - Нам не приходится инициализировать все слова в памяти.

    **Минусы**
    - Мы все еще заисим от длины строки. Необходимо вспомнить, что строки в питоне являются неизменяемым типом данных. Это значит, что если вы пытаетесь что-то поменять в строке, то вы создаете новую строку. Выходит что нам инетересен только крайнее слово, но мы все равно затрагиваем все остальные слова в той или иной степени.

- ### Решение **без Strip**:
    Зная проблемы предыдущих решений, мы приходим к тому, что не стоит изменять строку или каким-либо образом ее преобразовывать. Значит необходимо научить отличать пробелы. Пробел который идет слева от слова, является точкой остановки, пробелы справа не должны как либо влиять на счет.

    ```python
    def length_of_last_word(s: str) -> int:
        answer = 0
        for i in range(len(s) - 1, -1, -1):
            if s[i] == " ":
                if answer == 0:
                    # Если наш счетчик равен нулю, 
                    # значит мы еще не встречали буквы и 
                    # эти проблемы для нас не показательны.
                    continue
                # Если наш счетчик не равен нулю, 
                # значит мы уже встречали буквы и 
                # прошли все слово целиком.
                return answer
            answer += 1

        return answer

    assert length_of_last_word("Hello world    ") == 5
    ```
    **Плюсы**
    - Нам не приходится инициализировать все слова в памяти.
    - Мы больше не зависим от длины всей строки и сложность данного решения будет O(n), где n это длина последнего слова в строке, в худшем случае это будет длина всей строки, но в среднем сильно меньше.

    **Минусы**
    - Решение сильно хуже читается, чем решение с **Split**



