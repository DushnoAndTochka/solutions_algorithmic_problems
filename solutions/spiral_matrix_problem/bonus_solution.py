from typing import List


class Solution(object):
    """
    Данное решение является более фановым и запутанным. 
    Возможно с первого раза идея будет не понятна, поэтому предлагаю порисовать на листочке.

    Решение базируется на том, как ведут себя числа в данной матрице.
    Покажу на примере

    Например к нам пришла задача заполнить матрицу 6 Х 6
    Конечный результат должен выглядеть вот так:

     1  2  3  4  5  6
    20 21 22 23 24  7
    19 32 33 34 25  8
    18 31 36 35 26  9
    17 30 29 28 27 10
    16 15 14 13 12 11

    Можно заметить, что верхний треугольник является слева на право возрастающим.

     1  2  3  4  5  6
    20 21 22 23 24
       32 33 34 

    Если представить сколько есть всего "завитков" в данной спирале, то мы поймем, что завитков не может быть больше,
        чем min(M // 2, N // 2). Таким образом мы можем понять сколько будет таких слоев и когда стоит остановиться;
    + Совершенно не сложно определить позицию этих возрастающих последовательностей. Они начинаются с индекса, где i == j - 1
        и закканчивается на индексе, где i == M - j

    Следом стоит заметить еще одну особенность
    
    Есть подобная картина и она симметрична этой, только снизу. Там все числа убывают с лева на право

          36 35
       30 29 28 27
    16 15 14 13 12 11

    Их я решил обрабатывать через простое "иначе", что бы не морочиться с условием и там

    Дальше есть еще две особенности, которые так же симметричны, только уже слева и с права

    Слева все числа, которые мы еще не тронули, убывают сверху вниз
    А справа наоборот

    Слева            Справа
                          6
    20                24  7
    19  32         34 25  8
    18  31  36     35 26  9
    17  30            27 10
    16                   11


    Итогом мы видим 4 треугольника, в которых есть однозначное и понятное поведение.

    Если мы в верхнем треугольнике, то текщее число, больше предыдущего
    Если мы в левом, то текущее меньше того, что над ним
    Если мы в правом, то текущее больше чем то, что над ним
    Если мы в нижнем, то текущее меньше того, что с лева от него

    Осталось только зацепиться хотя бы за одно число, что бы все заполнить. 
    Но мы умеем считать верхний треугольник, а значит остальные можно посчитать отталкиваясь от него. 
    
    """


    def spiral_matrix(self, n: int, m: int) -> List[List[int]]:
        res = []
        # Ищем середину
        max_val_row_pos = n // 2
        max_val_col_pos = m // 2

        for row_num in range(n):
            new_row = []
            for col_num in range(m):
                # Сложное и не очень красивое условие, которое позволяет определить, что мы в верхнем треугольнике. 
                # См. текст выше
                is_up_tringle = col_num + 1 >= row_num and col_num <= m - row_num - 1
                if is_up_tringle:
                    # Расчет делается через "слои". 
                    # каждый слой начинается с числа на 1 больше, чем закончился предыдущий.
                    # Более подробно можно почитать в этой же директории(файл solution)
                    new_row.append(n * m - (n - 2 * row_num) * (m - 2 * row_num) + 1 + col_num - row_num)
                elif col_num <= max_val_col_pos and col_num <= n - row_num - 1:
                    # Левый треугольник. Все его числа на 1 меньше, чем число которое над ним
                    new_row.append(res[row_num-1][col_num] - 1)
                elif col_num > max_val_col_pos and m - col_num <= n - row_num:
                    # Правый треугольник. Все его числа на 1 больше, чем число над ним
                    new_row.append(res[row_num-1][col_num] + 1)
                else:
                    # Треугольник снизу. Все его числа на 1 меньше, чем число перед ним
                    new_row.append(new_row[-1] - 1)
            res.append(new_row)
        
        return res

    @staticmethod
    def print_result(result: List[List[int]]) -> None:
        """Вспомогательная ф-ция. Помогает красиво выводить ответ."""

        for row in result:
            for i, num in enumerate(row):
                num_str = str(num)
                row[i] = (4 - len(num_str)) * " " + num_str
            print(*i)
