# Minimum ASCII Delete Sum for Two Strings Solution

## Описание

> Ну вот и очередная задача на динамическое программирование... Знаю вы скучали =)

Как и всегда, не очень понятно с какого угла подойтись. Поэтому будем упрощать задачу до чего то простого, а потом усложнять до реальной задачи. 

У нас есть две строки. По сути нам надо найти самые длинные общие "разорванные" подстроки. То есть такие строки, что если из изначальных удалить минимальное кол-во символов, то мы получим одно и тоже.

```
s1 = leet
s2 = peet
```

Общее в обеих строказ - `eet`. Если же между итоговым вставить любое кол-во **не общих** символов, то результат не поменяется

```
s1 = leet
s2 = peret
```

Тот же результат.

То есть нам важна последовательность символов. Нам важно что бы как можно символов оставалось одинаковыми для обеих строк. В таком случае мы удалил минимальное кол-во символов.


Теперь давайте подумаем как можно было бы подобное сделать.

### Решенеи мысли в слух

> Данное решение скорее поток мыслей автора. Оно лишь показывает как можно мыслить. Если интересно реальное решение, пропускай данный пункт, мало что потеряешь.

- Создать результирующий список
- Можно идти по одной из двух строк. 
- Брать символ и искать его наличие в другой.
- Нашли ? Добавляем в результирующий массив.
- Итогом получаем кашу из индексов в которой нам необходимо найти самую большую возрастающую последовательность.

Это даже звучит сложно... 

```
# идем по s1 и ищем в s2
s1 = leet
s2 = peret

result = [1, 3, 1, 3, 4]
```

В данном случае все не так сложно. Мы получим итогом что-то в духе `[1, 3, 4]`, это индексы общих символов, которые составят самое большое общее слово. Но этот поиск будет дорого нам стоить. Ведь может выйти, что между двумя числами, которые составят возрастающую подпоследовательность, залезет еще одна, но менее успешная... В общем данный алгоритм реализуем и будет работать, НО тут многое надо учитывать.

## DP

А теперь давайте представим, что у нас есть такие входные данные

```
s1 = ''
s2 = 'peer'
```

Сразу же понятно, что надо удалить ВСЕ символы из второй строки, тогда обе строки станут одинаковыми ?

А что если данные будут выглядеть так

```
s1 = 'l'
s2 = 'peer'
```

А что если у нас будет такое ?

```
s1 = 'e'
s2 = 'peer'
```

тут уже интересно. С точки зрения результата мало что поменяется, но вот с точки зрения самого слова(представим что каждая буква уникальна сама по себе), все меняется. Наше второе слово разваливается на 2 варианта удаления

```
pe r
p er
```

давайте попробуем построить матрицу такого удаления

Первая строка это слияние пустой s1 и полной s2 с попытками найти хоть 1 совпадение. Итогом получаем все слово s2 под удаление

```
          p   e     e     r
    |---|---|----|-----|------|
    |   | p | pe | pee | peer |
    |---|---|----|-----|------|
 l  | l | p | pe | pee | peer |
    |   | l |  l |  l  |  l   |
    |---|---|----|-----|------|
```

С пустой строкой около понятно. Мы как бы смотрим пустой символ и пытаемся его вытащить из итоговой строки. Там такого символа нет, Поэтому мы потихоньку накапливаем все буквы из исходной строки под удаление.
Дальше мы берем букву l и так же сразу ее отправляем в удаление. Отменить свое решение мы можем только в том случае, если мы встретили такую же букву в втором слове поиска. 

Пока что под удаление у нас идут ВСЕ буквы `peerl`. То есть если бы строка была `l`, а вторая `peer`, то мы честно удалили бы вообще все.

```
          p   e     e     r
    |---|---|----|-----|------|
    |   | p | pe | pee | peer |
    |---|---|----|-----|------|
 l  | l | p | pe | pee | peer |
    |   | l |  l |  l  |  l   |
    |---|---|----|-----|------|
 e  | l | p |  p | pe  |  r   |
    | e | l |  l |  l  |  pel |
    |   | e |    |     |      |
    |---|---|----|-----|------|
```

А вот тут уже начинается ЖАРА. Добавляем букву `e` и по началу картина таже самая. Мы пытаемся грохнуть `le` из первой строки и все что попадется на пути из второй, если оно не равно букве поиска `e`. А что делать если мы встретили букву в слове поиска(`peer`) ? Мы должны представить, что такой буквы попросту никогда не было для обоих слов! Те откатиться в состояние, когда в первом слове была только буква `l`, а в втором `p`. Другими словами взять значение по диагонале, так как оно еще не знает о текущих одинаковых буквах, НО знает о всех остальных.

Теперь мы не хотим удалить вообще все. Это кажется понятным. Ведь точно одна буква у нас теперь общая и ее мы точно не хотим удалять. Получаем, что нам надо удалить `pelr` из двух слов и мы получим две одинаковых строки `e`. 

Еще очень важно заметить, что в первой строке мы `l` прибавляли к слову выше, а тут почему-то повели себя иначе... Это должно показаться странным. Почему мы взяли за основу `pel` и уже к нему добавили `r` ? Все дело в том, что нам надо удалить как можно меньше букв. У нас есть два варианта:

- Взять набор букв из предыдущей строки на текущей позиции, ведь именно из мы смогли там накопить под удаление, а уже к ним доавить текущую `e`. Либо взять то что мы успили накопить под удаление в текущей строке и добавить к этому `r`. В чем разница ? В кол-ве удаляемых символов. Нам надо удалить как можно меньше. Так что если мы смогли дойти до этой позиции с меньшим набором символов под удаление, то не стоит рубить с плеча.

Супер. Давайте расширяться дальше и смотреть как оно себя ведет

```
          p   e     e     r
    |---|---|----|-----|------|
    |   | p | pe | pee | peer |
    |---|---|----|-----|------|
 l  | l | p | pe | pee | peer |
    |   | l |  l |  l  |  l   |
    |---|---|----|-----|------|
 e  | l | p |  p | pe  |  r   |
    | e | l |  l |  l  |  pel |
    |   | e |    |     |      |
    |---|---|----|-----|------|
 e  | l | p |  p |  p  |  r   |
    | e | l |  l |  l  |  pl  |
    | e | e |  e |     |      |
    |   | e |    |     |      |
    |---|---|----|-----|------|
```

Вот тут уже идея начинает принимать все свои грани. Начало как и обвчно. Мы не обращаем никакого внимания на то, что у нас есть уже буква, которую мы нашли. Ведь в самом начале это и правда не имеет значения и у нас может найтись какая-то более интересная последовательность букв. Как только мы встречаем одинаковые буквы на пересечении, то вспоминаем правило. Представить что этих двух букв никогда и не было, НО остальные были. Значит подсматриваем по диагонали. Так же не забываем, что мы хотим удалить поменьше. Значит выбираем какую букву и куда "приклеивать"


```
          p   e     e     r
    |---|---|----|-----|------|
    |   | p | pe | pee | peer |
    |---|---|----|-----|------|
 l  | l | p | pe | pee | peer |
    |   | l |  l |  l  |  l   |
    |---|---|----|-----|------|
 e  | l | p |  p | pe  |  r   |
    | e | l |  l |  l  |  pel |
    |   | e |    |     |      |
    |---|---|----|-----|------|
 e  | l | p |  p |  p  |  r   |
    | e | l |  l |  l  |  pl  |
    | e | e |  e |     |      |
    |   | e |    |     |      |
    |---|---|----|-----|------|
 e  | l | p |  p |  p  |  r   |
    | e | l |  l |  l  |  plt |
    | e | e |  e |  t  |      |
    | t | e |  t |     |      |
    |   | t |    |     |      |
    |---|---|----|-----|------|
```

Это очень простой пример, но он показывает суть работы. Что основное в нем ?

- Если встретили ту же тамую букву, то давайте представим что ее никогда не было. А это было шагом на соседней клетке по диагонали. 
- Если у нашей клетки разные соседи сверху и слева, то выбирать мы будем ту, в которой меньше символов(либо по сумме `ord` они меньше), ведь мы хотим удалить меньше. Данная нужда появляется ТОЛЬКО после нахождения хотя бы одного общего. В ином случае без разницы куда и кого клеить. Посмотрите на конец второй строки. Там получается `peel` + `r` == `peer` + `l`, естественно с точки зрения набора символов. А вот уже на строке `3` мы получаем иную картину `pel` + `r` < `peerl` + `e`. Значит выбирать мы должны поменьше. Это и логично, ведь букву `e`, мы уже "спасли".


```python
class Solution:
    def minimum_delete_sum(self, s1: str, s2: str) -> int:
        m, n = len(s1), len(s2)

        # создаем матрицу как рисовали
        dp = [[0] * (n + 1) for _ in range(m + 1)]

        # заполняем для случае с пустыми строками 
        # В таком случае мы бы удалили все слово 
        for i in range(1, m + 1):
            dp[i][0] = dp[i - 1][0] + ord(s1[i - 1])
        for j in range(1, n + 1):
            dp[0][j] = dp[0][j - 1] + ord(s2[j - 1])

        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if s1[i - 1] == s2[j - 1]:
                    # Если одинаковые буквы,
                    # то смотирм по диагонали
                    dp[i][j] = dp[i - 1][j - 1]
                else:
                    # Берем то, что меньше по сумме,
                    # ведь мы не хотим удалить
                    # слишком много букв
                    dp[i][j] = min(
                        dp[i - 1][j] + ord(s1[i - 1]),
                        dp[i][j - 1] + ord(s2[j - 1])
                    )

        return dp[m][n]
```

# PS

Спасибо что дочитали. 
В этот раз пришлось подсмотреть годное решение у ребят с LeetCode. Там же я нашел несколько годных объяснения, так что если было не понятно, думаю можно посмотреть их рассуждения на данный случай

[тут даже видео](https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/solutions/3840553/100-dp-video-decoding-approach-to-minimum-ascii-delete-sum/), но решение немного отлично. Хотя идея ровна таже самая.