# SymmetricTree Problem

Идея решения обходить такая:

Берем правую часть и левую и сравниваем их.

Функция сравнения делает следующее:

 - Проверяет равны ли элементы None (если да, то возвращает результат)
 - Сравниваем значения элементом
 - Далее сравнивает рекурсивно правый с левым элемент, а левый с правым


```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


def is_equal(lhs: TreeNode | None, rhs: TreeNode | None):
    # Если один из элементов None, то возвращает результат
    if lhs is None:
        return rhs is None
    if rhs is None:
        return False
    # Если элементы не совпадают, то возвращаем False
    if lhs.val != rhs.val:
        return False
    # Сравнимаем правый с левым, а левый с правым
    return is_equal(lhs.left, rhs.right) and is_equal(lhs.right, rhs.left)


class Solution:
    def is_symmetric(self, root: TreeNode | None) -> bool:
        # Если элемент равен None то возвращаем True
        if root is None:
            return True
        # Сравниваем левый с правым
        return is_equal(root.left, root.right)
```

Некоторые моменты которые хочется упомянуть.

Нейминг может показаться странным на первый взгляд. Но если его расшифровать, то всё становится понятно:

lhs - left hand side
rhs - right hand side

Так же стоит обсудить сложность алгоритма - на каждый элемент мы делаем константное количество действий, поэтому по времени алгоритм работает за O(N).

А по памяти интересней, мы не используем массивы или что-то такое и может показаться что мы не используем память - то есть первое предположение что мы используем O(1).

Но такое предположение не правильное, так как мы используем рекурсию, а поэтому мы используем стек и сложность по памяти будет равно количеству  рекурсивных вызовов.

А так как их может быть N/2, поэтому сложность по памяти будет O(N).