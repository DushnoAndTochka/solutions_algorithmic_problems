# Find Eventual Safe States Solution

## Описание

Решение заключается в том, что бы пройтись по всем связям и запомнить какие из них безопасные, а какие имеют зацикливание. Единственная причина небехопасности ноды, это если имеется цикл. Мы будем брать ноду и постепенно идти от нее по всем связям, отмечая свое посещение. Если мы попадем на ноду, которую уже посетили, значит у нас есть цикл. Если этого не произошло и мы уперлись в ноду из которой нет исходящих связей, значит мы дошли до безопасной. После этого мы начинаем постепенно подниматься и отмечать все ноды, которые посетили ранее, как безопасные.

```python
class Solution:
    def eventual_safe_nodes(self, graph: list[list[int]]) -> list[int]:
        # чисто для читабельности создадим статус для нод
        node_statuses = {
            "NOT_VISITED": 0,
            "VISITED": 1,
            "SAFE": 3
        }
        # создадим карту статусов каждой из ноды.
        # изначально мы нигде не были, поэтому все они NOT_VISITED
        status = [node_statuses["NOT_VISITED"]] * (len(graph))
        res = []

        def is_safe_node(node: int):
            # Если мы проверяем ноду, статус которой уже
            # "посещенный", значит у нас цикл
            if status[node] == node_statuses["VISITED"]:
                return False
            # Если попали на "безопасную", значит нечего проверять
            if status[node] == node_statuses["SAFE"]:
                return True
            # отмечаем ноду как посещенную, что бы
            # в случае цикла это задетектить
            status[node] = node_statuses["VISITED"]

            # берем все исходящие ноды и проверяем их статус
            for outgoing_node in graph[node]:
                # Если эта нода не безопасная, значит
                # и текущая так же не безопасная
                if not is_safe_node(outgoing_node):
                    return False
            # Если все ноды оказались безопасными,
            # значит и текущая такова.
            # Отмечаем ее как безопасную
            status[node] = node_statuses["SAFE"]
            return True

        for i in range(len(graph)):
            if is_safe_node(i):
                res.append(i)
        return res
```

Прелесть решения в том, что нам не приходится каждый раз проверять все связи заново. Мы уже знаем их состояние, если работали с этой нодой. Итогом мы поработаем с каждой нодой ровно один раз, если не учитывать проверки... В любом случае сложность окажется линейной. Дополнительную память мы так же не мучаем и не перегружаем.
