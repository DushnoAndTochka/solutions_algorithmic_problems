# Pow(x, n) Solution

## Описание

Начнем с самого простого решения.

```python
class Solution:
    def my_pow(self, x: float, n: int) -> float:
        return x**n
```

В случае с тестами литкода, все пройдет успешно. Но по скорости и памяти будет не самым оптимальным. Давайте подумаем как его можно ускорить.

Предлагаю начать с базового, что такое возведение в степень ?

По своей сути, возведение в степень, это перемножения числа `n` раз, где `n` степень числа.

Например:

```
x = 2
n = 6

result = 2 * 2 * 2 * 2 * 2 * 2
```

Что бы в лоб посчитать такое, нам прийдется 6 раз перемножать двойку и результат. Это долго на больших числах...

А что если сократить кол-во действий ? Мы знае, что `2 * 2 == 4`, а `4 * 4 == 2 * 2 * 2 * 2`, то есть мы можем каждый раз не высчитывать чему будет равно `2 * 2`, а использовать уже знания, которые получены ранее.

Например:

```
x = 2
n = 6

result = 2 * 2 * 2 * 2 * 2 * 2 = 4 * 4 * 4
```

в данном случае нам понадобится всего 3-и действия. Первым мы узнаем чему равно произведение `2 * 2`, а дальше перемножим `4` три раза. Если степень окажется выше, например `8`, то мы еще сильнее сократим и получим `16 * 16 == 4 * 4 * 4 * 4 == 2 * ... * 2`. 

```python
class Solution:
    def my_pow(self, x: float, n: int) -> float:
        # с нолем вообще ничего не поделаешь.
        # Это всегда 1 для любого числа
        if n == 0:
            return 1
        # Если n меньше -1, например -2 и так далее,
        # то стоит заняться перемножением
        # Если больше 1, то таже самая история
        if -1 > n or n > 1:
            # У числа, который мы получим,
            # степень возведения будет в два раза ниже,
            # чем у текущего.
            # Наприме:
            # 2 ** 6 == 4 ** 3
            next_n = n // 2
            
            # Если текущая степень нечетная,
            # то мы должны еще и на само
            # число будем домножить
            if n % 2 != 0:
                x *= self.my_pow(x * x, next_n)
            else:
                x = self.my_pow(x * x, next_n)
        elif n == -1:
            # если мы дошли до -1, значит вспоминаем правило
            # a ** -n == 1 / (a ** n)
            x = 1 / x

        x: float # линтер ругается =)
        return x
```