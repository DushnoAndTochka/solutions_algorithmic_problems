# LinkedListCycle Solution


## Решение через знание MAX длины связанного списка.
По условию задачи мы знаем, что список не превысит длины 10^4, а это всего то 10000. так почему бы нам не сделать 10001 действие ? Если мы не встретили None на пути, значит мы прошли точно больше, чем могли, а значит и связанный список сто процентов закциклен

```python
def solution(l: Optional[Node]):
    if l is None:
        return False

    for i in range(10001):
        l = l.next
        if l is None:
            return False
    
    return True
```
### Минусы:
- Решение конечно очень забавное. В случае если список зациклен, то нам прийдется долго по нему гулять... 

### Плюсы:
- По сути никакой лишней памяти.

---
## Решение через hash table.
Многим могла прийти идея, а почему бы не запоминать в каком-то месте ноды, которые мы уже посещали ? Если при проходке нода нашлась в hash_t, то значит мы уже тут были. 
В целом это рабочее решение.

```python
def solution(l: Optional[Node]):
    hash_t = dict()

    while l is not None:
        if l in hash_t:
            return True
        hash_t[l] = 1
        l = l.next

    return False
```
### Минусы:
- Выделяем кучу памяти. А в случае, если нет цикла, то еще и не оправданно.

### Плюсы:
- Мы сможем закончить ровно за O(n). Сложность тут будет линейная, так как поиск по hash таблице выполнится за O(1).

---
## Решение с "хлеными крошками".
Как и в сказке, мы можем сыпать хлебные крошки. Если мы их обнаружили, значит мы тут уже были.

Что за крошки спросите вы ? Все просто, мы будем уродовать содержимое val. В Python у нас есть два варианта того, как это можно сделать.
- Так как язык не типизированный, то мы можем в val положить строку, например какую-то букву. Так как в исходных нодах этого не предполагалось, то если мы встретили строку, значит мы в цикле. Но такое не прокатит в статически типизированных языках...
- А что если положить в val число, которое на 1 больше максимального ? Нам по условию сказали, что максимально число в val это 10^5, значит мы можем положить 10^5 + 1 в каждую ноду где уже были. Если мы встретим 10^5 + 1, то можно смело утверждать о зацикленности.

Оба варианта приемлемы. Каждый в праве выбрать свой.

### Минусы:
- Мы изменяем входные данные. Порой это очень плохо и об этом стоит помнить.

### Плюсы:
- Мы не используем доп память.
- Сложность линейная.
