# SearchInRotatedSortedArray II Solution

## Описание
Решение более сложное ем в оригинальной задаче `SearchInRotatedSortedArray`, ее разбор есть.

Усложняется данное решение тем, что на левом поинтере может лежать число, которое равно правому, а посередине будут еще какие то числа...

```python
nums = [1, 1, 1, 1, 0, 1, 1, 1]

target = 0
```

получается что на моменте мы никак не можем понять где вообще искать.
Мы можем выставить середину, если она равна сразу и левому, и правому, то куда двигаться ?

Ответ к сожалению пока что такой:
- Двигать границы в сторону середины по `1`.

Это может привести к линейной скорости поиска, особенно в таком сценарии

```
nums = [1, 1, 1, 1, 1, 1, 1, 1]

target = 0
```

Те мы будем двигать границы и `потрогаем` каждое чило в данном списке.

### Закончим с грустным =)
Теперь давайте поймем как искать, учитывая факт, что изложен выше.

Найдя середину нам надо понять следующее:
- Какая часть отсортированна ? Если `mid < right`, то справа отсортированный кусок. Eckb `mid > left`, значит слева отсортированный, в ином случае у нас может быть только равенство, значит начинаем двигать как описано ранее.
- Нашли какая часть отсортированна ? Тогда просто посмотрим не находится ли в ней наш `target` ? Если да, то счатье нам улыбнулось. У нас отсортированный массив и в нем таргет, такое легко искать. Если нет, то значит прийдется искать в той части, где возможно есть разрыв, а значит мы возвращаемся к предыдущему пункту.

---
PS

Я верю, что есть более красивое решение, но пока что не смог его придумать или найти. Если знаете, то смело пишите, можно и PR кидать.

Заранее спасибо =)