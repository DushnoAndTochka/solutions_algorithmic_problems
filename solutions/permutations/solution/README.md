# Permutations Solution

## Описание:

Задача просит нас найти все варианты перестановок. Самым простым и очевидным будет решение через дерево.

Выглядеть будет как то так

```
               [] | [1 2 3]
               ------------
              /     |      \
         1|2 3     2|1 3    3|1 2
         /  \      /  \      /  \
      12|3 13|2  21|3 23|1 31|2 32|1
        |   |     |    |    |    |
       123 132   213  231  312  321
```

Надеюсь что суть понятна из картинки.

В двух словах. Мы имеем массив итоговый, изначально он пустой, и массив чисел, которые хотим скомбинировать. Берем число из второго массива, добавляем в итоговый, остаток запоминаем. Берем следующее число и запоминаем какие еще были числа и так далее. 

НО это решение мне показалось слишком типовым и скучным...

Как же еще можно решить данную задачу ? 

Перестановками =)

Что бы понять всю идею, нам надо хотя бы 2 числа, а лучше три.
Давайте разберем сразу на примере

Пусть `nums = [1, 2, 3]` 

Мы берем первое число и помещаем в результирующий массив

```
result = [[1]]
```

С ним мы буквально ничего не можем сделать. Если бы у нас была только 1, то это и был бы ответ. Теперь добавим к нему следующее число из списка и получим массив `[1, 2]`. Вот тут и начинается самое интересное. Если крутануть этот массив на единицу меньше его длины, то мы получим все варианты его перестановок... Звучит как бред ? подождите, скоро объясню

```python
res = [[1, 2]]

res.append([2, 1]) # одно вращение

res -> [[1, 2], [2, 1]]
```

Тут пока что должно быть мало что понятно. Но ответ опять же сошелся бы, если бы мы имели только два числа.

Теперь давайте возьмем следующее число `3`. Его необходим добавить к двум уже имеющимся массивам и так же прокрутить сколько это возможно раз.

```python
res = [
    [1, 2],  # append(3)
    [2, 1]   # append(3)
]

res -> [[1, 2, 3], [2, 1, 3]]
```

А теперь крутим первый массив. Под кручением я подразумеваю сдвиг всех элементов на 1 индекс

```
1 2 3 -> 2 3 1 -> 3 1 2
2 1 3 -> 1 3 2 -> 3 2 1
```

После добавление всего в результирующий массив, мы опять получим все варианты комбинирования

```python
res = [
    [1, 2, 3],
    [2, 3, 1],
    [3, 1, 2],
    [2, 1, 3],
    [1, 3, 2],
    [3, 2, 1],
]
```

Что ж, если мы теперь решим добавить 4, то нам надо будет так же добавить ее к каждому из имеющизся массивов и провернуть их. Тогда мы снова получим Все варианты комбинирования.

Это решение не является лучшим, но мне оно показалось как минимум интересным.

```python
class Solution:
    def permute(self, nums: list[int]) -> list[list[int]]:
        # создаем итоговый массив
        result = [[]]

        # пошли по входным данным
        # Важно что тут не больше 6 итераций
        for num in nums:
            # пошли по всем результирующим массивам,
            # которые появились на каждом из уровней
            for i in range(len(result)):
                # создаем массив, который будем "вертеть"
                result[i].append(num)
                # пошли вертеть массивы
                for j in range(len(result[i]) - 1):
                    res = [] # новый вариант после прокрутки
                    # что бы не копировать и не мучаться с
                    # перестановками, делаем удобный цикл,
                    # который будет заходить в
                    # отрицательные числа
                    for k in range(-1 - j, len(result[i]) - 1 - j):
                        # добавляем число
                        res.append(result[i][k])
                    result.append(res)

        return result
```

Это очень наркоманское решение, тут я даже не буду спорить. НО оно не плохо экономит память. Нам не приходится создавать лишних данных. Все данные которые мы создаем уже конечны. Сложность тут конечно оставляет желать лучшего =) Благо мы ограничены 6 числами и больше нам не прийдется комбинировать. Сложность будет близка к факториальной с множителем. А при 6 элементах у нас будет 720 комбинаций =) не стоит этого забывать. Так что сложность тут сама по себе врядли может быть сильно низкой.
