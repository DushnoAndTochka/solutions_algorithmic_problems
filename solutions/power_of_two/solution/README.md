# Is power of 2? Solution

Первое решение которое может прийти в голову:

- Начать с 1
- Увеличивать в 2 раза значение до тех пор пока не превысит n


```python
class Solution:
    def is_power_of_two(self, n: int) -> bool:
        c = 1
        
        while c <= n:
            if c == n:
                return True
            c *= 2
        return False
```

Давайте попробуем найти асимптокику решения?

Может показаться что асимптотика `log(n)`, но `n` не может превысить 2^32, то есть не может превысить `log(2**32)`, то есть не может превысить 32 и можно сказать что данное решение работает за константу (как по времени так и по памяти)

Но можно ли его улучшить?

Да, можно все 32 числа найти заранее и просто проверить, присутствует ли число в set

```python
class Solution:
    _ALL = {
        2**i
        for i in range(32)
    }
    
    def is_power_of_two(self, n: int) -> bool:
        return n in self._ALL
```

Сейчас мы один раз расчитываем все возможные значения на этапе импорта, а запуск самой функции работает за константу (намного меньше, чем в первом решении)

А можем ли мы еще улучшить?

И ответ да и тут нам поможем бинарное представление числа


Бинарное представление любого числа, которое является степенью двойки это 

```shell
100...0
```

(Количество нулей, это степень двойки)

То есть `2^3` это `1000`

Если мы отнимем от этого числа 1 то бинарное представление будет

```shell
11...1
```

(Количество едениц зависит от степени двойки)

А теперь возьмет бинарное представление n и n-1 и найдем побитовое & для этих чисел

```shell
10000000
&
01111111
=
00000000
```

То есть всегда будет 0 и будет 0, только для степени двойки

```python
class Solution:
    def is_power_of_two(self, n: int) -> bool:
        if n == 0:
            return False
        return n & (n - 1) == 0
```

И это решение работает за константу (максимально быстрое)