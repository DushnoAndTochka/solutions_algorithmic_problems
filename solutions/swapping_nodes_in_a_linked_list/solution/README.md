# Swapping Nodes in a Linked List Solution

## Описание

Как и во многих задачах, для начала надо точно понять что именно мы хотим найти. 
- Ноду на удалении `k` от начала.
- Ноду на удалении `k` от конца.

Давайте решать постепенно. Для начала разделим задачу на две части:
1. Поиск нужных `node`
2. Поменять местами найденные `node`

Начнем с решения первой проблемы.

### Поиск в лоб.
Первое что приходит в голову, пойти от начала и искать `node` на расстоянии `k` от начала, следом искать от конца. НО как это сделать ?

На помощь нам прийдет два поитера. Мы можем запомнить ноду и ждать пока основной указатель не отойдет на расстояние `k`, после это начать двигать ноду, которая позади.

Звучит сложно ? Сейчас разберем на примере кода.

```python
def solution(head, k):
    # node - то что будет двигаться по всему списку
    # left_n - нода на расстоянии k от начала
    # right_n - нода на расстоянии k от конца
    node = left_n = right_n = head

    # так как мы встретили уже 1 ноду(head), то считаем ее.
    # счетчик нам позволит понять когда остановиться
    # left_counter - момент остановки от левого края
    # right_counter - момент остановки от правого края
    right_counter = left_counter = 1


    # пока есть куда шагать, шагаем
    while node.next:
        node = node.next

        if left_counter < k:
            left_n = node
            left_counter += 1

        if right_counter < k:
            right_counter += 1
        else:
            # если правый счетчик отошел на расстояние k,
            # то можно начинать двигать за ним node
            right_n = right_n.next

    print(left_n, right_n)
```

Этот код в лоб ищет обе ноды. Давайте немного нарисуем как это выглядит

```
k = 2


head
  |
  V
  1 -> 2 -> 3 -> 4 -> 5
```

#### Шаг 1
```
k = 2

node
head
  |
  V
  1 -> 2 -> 3 -> 4 -> 5
  ^
  |
left_n
right_n

left_counter = 1
right_counter = 1
```

#### Шаг 2
```
k = 2

     node
head   |
  |    |
  V    V
  1 -> 2 -> 3 -> 4 -> 5
  ^    ^
  |    |
  |  left_n
right_n

left_counter = 2
right_counter = 2
```
Видим что у левой ноды от края 2 ноды, включая ту на которую она указывает. Значит ее больше не двигаем. Между `right_n` и `node` так же уже две ноды, включае те на которые они указывают, значит можно начинать двигать `right_n`, что бы не потерять это расстояние до самого края.

#### Шаг 3
```
k = 2

          node
head        |
  |         |
  V         V
  1 -> 2 -> 3 -> 4 -> 5
       ^
       |
     left_n
     right_n

left_counter = 2
right_counter = 2
```

#### Шаг 4
```
k = 2

               node
head             |
  |              |
  V              V
  1 -> 2 -> 3 -> 4 -> 5
       ^    ^
       |    |
     left_n |
         right_n

left_counter = 2
right_counter = 2
```

#### Шаг 5
```
k = 2

                    node
head                  |
  |                   |
  V                   V
  1 -> 2 -> 3 -> 4 -> 5
       ^         ^
       |         |
     left_n      |
              right_n

left_counter = 2
right_counter = 2
```

Дошли до конца. Теперь мы уверены, что левая находится там где необходим и правая так же дошла до правильного расстояния.

Надеюсь теперь идея понятно. Можно ли улучшить решение ? Да, читаем дальше

### Решение через общий счетчик

Нам нет большой разницы в левом или правом счетчике, потому что считают они одно и тоже. Так что из можно объединить и упростить решение. Но не сказать что оно сильно поменяется.

```python
def solution(head, k):
    # node - то что будет двигаться по всему списку
    # left_n - нода на расстоянии k от начала
    # right_n - нода на расстоянии k от конца
    node = left_n = right_n = head

    # так как мы встретили уже 1 ноду(head), то считаем ее.
    # счетчик нам позволит понять когда остановиться
    counter = 1


    # пока есть куда шагать, шагаем
    while node.next:
        node = node.next

        if counter < k:
            left_n = node
            counter += 1
        else:
            # если счетчик отошел на расстояние k,
            # то можно начинать двигать за ним node
            right_n = right_n.next

    print(left_n, right_n)
```

Теперь мы умеем искать нужные нам ноды. Но их еще необходимо поменять местами. Об этом дальше

## Меняем ноды местами

Думаю вы понимаете основную проблему поменять ноды в этой задаче. Что бы поменять ноды, нам надо остановиться непосредственно перед ними. и уже после этого менять ссылку на них, а у них менять ссылку на следующие ноды...

Звучит тяжело ?

Исходный список
```
1 -> 2 -> 3 -> 4 -> 5
```
Подменим ссылку на нужные нам ноды. Тем самым мы разорвем связанный список на два.
```
1 -> 4 -> 5
3 -> 2 -> 3 -> ......
```
Осталось поменять ссылки самих нод на следующие за ними. 
```
1 -> 4 -> 3 -> 2 -> 5
```

Профит. Мы молодцы.

Но это все еще не так уж и просто.

А что если скажу, что можно просто поменять значения в самих нодах и не заморачиваться с тем что я описал выше ? Звучит заманчиво. Нода не хранит никакой полезной информации кроме значения в ней, так давайте и поменяем это самое значение. Итоговое решение:


```python
def solution(head, k):
    node = first_node = last_node = head

    counter = 1

    while node.next:
        node = node.next
        
        if counter < k:
            first_node = node
            counter += 1
        else:
            last_node = last_node.next
        
    # нагло меняем местами значения
    first_node.val, last_node.val = last_node.val, first_node.val

    return head
```
