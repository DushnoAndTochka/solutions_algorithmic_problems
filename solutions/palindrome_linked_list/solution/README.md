# Palindrome Linked List Solution

## Описание:

Начнем с классических решения определения палиндрома на массиве(`Не связанном списке`)

1. Сравнение с концов к центру.

    ```
    ->               <-
    1   2   3    2    1
    |   |        |    |
    |   |__2==2__|    |
    |______1==1_______|
    ```

    То есть мы двигаемся от левого и от правого края, попутно сравниваем то что на указателе.

2. От центра к краям

    ```
          <- ->        
    1   2   3    2    1
    |   |        |    |
    |   |__2==2__|    |
    |______1==1_______|
    ```

    Оба указателя встают на центр и начинают сравнивать все встречающееся, пока не дойду до края.


Можно ли применить такое решение к связанному списку ? В целом да, но стоит помнить, что у нас одновсвязанный список, а это значит мы не можем двигаться в обе стороны одновременно(`решения выше подразумевает разнонаправленно движение)`.

Что это значит ? Значит что одним из указателей нам прийдется постоянно возвращаться назад...

```
left_node          right_node
    |                   |
    V                   V
    1 -> 2 -> 3 -> 2 -> 1
              ^
              |
           mod_node
```

Зная длину мы двигаемся от середины на `нужное` кол-во нод и сравниваем. При этом левая нода двигается адекватно и сама. То есть правой нодой нам прийдется на каждой итерации возвращаться в середину, проходить нужное кол-во нод в право и сравнивать с тем что слева.... Очень долго выглядит.

Есть такое же решение идти от середины, но там проблемы будут с левой стороной и ей уже прийдется гулять так же сложно.

> Идею развернуть связанный список в массив, что бы упростить задачу и решить ее классическим способом, я даже не предлагаю. Развернуть будет не сложно и сравнивать понятно как, НО это дорого по памяти.

Что же делать ?

Надо схитрить. Наша проблемма в том, что мы не можем ходить в обе стороны и можем идти только вперед нодами. Что же делать ? Развернуть одну из половинок.

Как это будет выглядить ?

```
Original: 1 -> 2 -> 3 -> 2 -> 1

 Reverse: 2 -> 1 -> 3 -> 2 -> 1
```

Те все ноды, которые идут до середины(или после, на ваш выбор), мы развернем. Таким обазом мы знаем середину, мы знаем начало и одна из сторона перевернута, значит мы можем просто в лоб из сравнивать



 ```
 Original: 1 -> 2 -> 3 -> 3 -> 2 -> 1
            ----------->
      left_node     right_node
          |              |
          V              V
Reverse: 3 -> 2 -> 1 -> 3 -> 2 -> 1 
```

Итого какие шаги для решения ?

1. Найти длину связанного списка. Без нее мы не сможем понять где середина.
2. Найти середину и развернуть все ноды до нее.
3. От середины, учитывая четность длинны, и от начала приступить к сравнению нод.
4. Профит!!!