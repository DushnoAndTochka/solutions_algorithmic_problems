# FindMinimumInRotatedSortedArray Solution

## Описание решения.
Самым простым решением будет пройтись в лоб и поискать минимальный элемент. Получим линейную сложность.

Но есть решение, которое куда эффективней. Мы можем через бинарный поиск искать место `разрыва`. Что это значит ? 

Давайте еще раз повторим условия, только вкратце.
Был отсортированный массив, его несколько раз подвигали и получили следующее.

```python
[8, 9, 0, 1, 2, 3, 4, 5]
```

Если подумать, то минимальный элемент можно было найти сразу, до того как сделали несколько сдвигов. ведь массив отсортирован, значит его первый элемент и был минимальным. НО его несколько раз сдвинули и теперь это правило не работает ? Не совсем.

Нам надо понять несколько правил, которые появились после сдвигов:
- Первый элемент массива всегда больше любого элемента после `разрыва`. Так как числа с конца переходили вначало, то они строго больше, чем числа, которые были вначале. `[8, 9]` > `[0, 1, 2, ..., 5]`. 
- Если предыдущее число больше тем текущее, значит мы нашли разрыв. В примере это будет `9, 0` потому что `9 > 0`.

Понимая то что выше, можно использовать бинарный поиск и искать этот самый `разрыв`.
- Если середина больше или равна первого числа, то значит массив разрыв еще не найден и находится явно правее.
    ```
    [7, 8, 9, 1, 2, 3, 4, 5]
    ```
    Любое из чисел `7, 8, 9`, говорит что надо искать правее, ведь пока что все выглядит нормально и удовлетворяет прваилу сортировки.
- Если середина оказалсь меньше первого числа, значит мы попали в место после разрыва. и надо искать левее.
    ```
    [7, 8, 9, 1, 2, 3, 4, 5]
    ```
    Любое из чисел `1, 2, 3, 4, 5` меньше чем 7, значит разрыв произошел и надо искать его левее.
- Если середина меньше, чем число перед ней, то мы нашли ответ. Это и есть место разрыва к которому привел сдвиг.

## Пример
```python
nums = [8, 9, 0, 1, 2, 3, 4, 5]
```

### Шаг1:
```python
 first
   |
   V

   8   9   10   11   2   3   4   5
   
   ^             ^               ^
   |             |               |

   Lp           mid              Rp
```
Видим что `mid >= first`, а значит массив до середины растет и не имеет разрыва. Значит надо искать `разрыв` правее, сдвигаем `Lp` на `mid`

### Шаг2:
```python
 first
   |
   V

   8   9   10   11   2   3   4   5
   
                 ^       ^       ^
                 |       |       |

                 Lp     mid      Rp
```
Видим что `mid < first`, а значит между `first` и `mid` был разрыв. НО мы уже посмотрели на поведение массива до текущего `Lp` и там все было нормально. Значит между `Lp` и текущим `mid` был разрыв.

### Шаг3:
```python
 first
   |
   V

   8   9   10   11   2   3   4   5
   
                 ^       ^       ^
                 |       |       |

                 Lp     mid      Rp
```
Видим что `mid < first`, а значит между `first` и `mid` был разрыв. НО мы уже посмотрели на поведение массива до текущего `Lp` и там все было нормально. Значит между `Lp` и текущим `mid` был разрыв. А значит сдвигаем `Rp` на текущий `mid`.

### Шаг4:
```python
 first
   |
   V

   8   9   10   11   2   3   4   5
   
                 ^   ^   ^       
                 |   |   |       

                 Lp mid  Rp      
```
Тут выполняется условие, что `mid < mid - 1`, то есть вышло так, что середина меньше, чем число перед ней, а это значит, что ответ найден.

```python
result = 2
```