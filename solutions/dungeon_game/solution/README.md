# Dungeon Game Solution

> Решение является продолжением, более сложных версий, к решениям: 
>- [Unique Paths](/solutions/unique_paths/solution/)
>- [Unique Paths II](/solutions/unique_paths_ii/solution/)

## Описание

Так как мы уже решали две подобные задачи, то и тут хочется применить схожее решение. Первым делом можно на автомате попытаться поискать решение в лоб, что бы начать идти от левого верхнего угла к принцессе и выбирать "оптимальный" путь. НО тут нащ же опыт сильно нас накажет. Так как будет крайне тяжело понять, какой из маршрутов выгодней. Почему ? Потому что у нас теперь два разных критерия
- Сколько мы теряли здоровья
- Сколько мы имеем здоровья

И невозможно выбрать "оптимальный" маршрут. Так как порой выгоден тот, где мы потратили меньше, так как дальше не прийдется тратить например. А может быть важно иметь много здоровья, что бы не просесть дальше в большой минус... Поэтому прежний подход нам не подойдет.

А точно не подойдет ? =)
Давайте рассуждать вместе. Как и всегда я предлагаю взять и нарисовать себе пример, а уже потом думать над ним.

Пример:

```
рыцарь
  |
  v
|---|---|---|
| -2| -3| 3 |
|---|---|---|
| -5|-10| 1 |
|---|---|---|
| 10| 30| -5| <- принцесса
|---|---|---|
```

Со стороны рыцаря мы не сможем ничего понять, это мы уже выяснили. Но а что если попробовать двигаться со стороны принцессы ? Мы точно можем сказать, что на последней клетке, где заточена принцесса, у нас должно быть `6` жизней, так как сражение с монстром финальным у нас гарантированно отнимет `5` единиц здоровья.


```
рыцарь
  |
  v
|---|---|---|
| X | X | X |
|---|---|---|
| X | X | X |
|---|---|---|
| X | X | 6 | <- принцесса
|---|---|---|
```

В эту клетку мы можем попасть только из двух соседних. Так давайте подумаем, сколько нам надо здоровья на вход в те клетки, что бы все так же было хорошо.

Возьмем для начала левую, она дает нам `30` жизней. Нам же надо иметь `6` на финальную клетку. Ниже `1` жизни мы не можем опускаться, иначе герой помрет. Значит если мы зайдем на клетку с `1` или большим количеством жизней, то получим `30` и точно спасем принцессу.

Теперь посмотрим на клетку над принцессой. Там нам подарят `1` дополнительную жизнь. НО нам то надо `6` для сражения на финале... Знаит входя на эту клетку, нам надо иметь хотя бы `5` жизней, тогда мы получим `1` и успешно пойдем сражаться с финальным монстром.

```
рыцарь
  |
  v
|---|---|---|
| X | X | X |
|---|---|---|
| X | X | 5 |
|---|---|---|
| X | 1 | 6 | <- принцесса
|---|---|---|
```

Так как двигаться наш герой может только вправо или вних, то нижняя грань и правая грань имеют лишь одно решение...

```
рыцарь
  |
  v
|---|---|---|
| X | X | 2 |
|---|---|---|
| X | X | 5 |
|---|---|---|
| 1 | 1 | 6 | <- принцесса
|---|---|---|
```

Надеюсь уже понятно почему так ? 

клетка [-1][0] даст нам `10` дополнительных жизней, а в следующую клетку можно идти и с `1` жизнью, что бы успешно пройти игру. Значит и на эту клетку, можно наступать с `1` и более жизнями, нам дальше ничего вообще не грозит, ведь мы "отхилимся" и легко всех победим.

клетка [0][-1] дает три жизни. Но переход в следующую требует минимум 5 жизней. Значит если мы зайдем с `2`, то тоже все будет отлично.

Мы заполнили грани, теперь осталось заполнить остальное. С ним усложняется выбором. Мы знаем сколько надо жизней, что бы идти куда то дальше и знаем сколько отнимет/прибавит текущая. Значит мы должны выбрать "оптимальную" следующую клетку, та что требует меньше жизней на входе и вычислить сколько надо было иметь для входа на текущую клетку... 

Ничего не напоминает ? То же самое что и в оригинале, только двигаемся мы с конца =) Так что не так уж и далеко ушла данная задача.

Вот так будет выглядеть заполненное поле требуемых жизней для каждой из клеток(советую сделать это самим, что бы понять как работает)

```
рыцарь
  |
  v
|---|---|---|
| 7 | 5 | 2 |
|---|---|---|
| 6 | 11| 5 |
|---|---|---|
| 1 | 1 | 6 | <- принцесса
|---|---|---|
```

Получается, что рыцарь должен зайти с `7` жизнями, что бы успешно пройти маршрут и не помереть по дороге.

А вот так будет выглядеть код:

```python
class Solution:
    def calculate_minimum_hp(self, dungeon: list[list[int]]) -> int:
        # клетка с принцессой. 
        # Если она хилит, то достаточно и 1 жизни на входе
        # Если монстр там, то надо на 1 жизнь больше,
        # что бы не умереть и забрать принцессу
        dungeon[-1][-1] = max(1 - dungeon[-1][-1], 1)

        for i in range(len(dungeon) - 2, -1, -1):
            # Заполняем правую грань
            dungeon[i][-1] = max(dungeon[i + 1][-1] - dungeon[i][-1], 1)

        for i in range(len(dungeon[0]) - 2, -1, -1):
            # Заполняем нижнюю грань
            dungeon[-1][i] = max(dungeon[-1][i + 1] - dungeon[-1][i], 1)

        for i in range(len(dungeon) - 2, -1, -1):
            for j in range(len(dungeon[0]) - 2, -1, -1):
                # Заполняем все оставшиеся переходы
                dungeon[i][j] = max(
                    # выбираем оптимальный дальнейший переход
                    min(dungeon[i][j + 1], dungeon[i + 1][j]) - dungeon[i][j],
                    1
                )

        return dungeon[0][0]
```
---

PS

Спасибо что дочитали до конца =)